--- Project Directory Tree ---
.
├── color.swift
├── draw.swift
├── image_generators.swift
├── main.swift
├── project.txt
├── project_doc.sh
├── prompt.txt
├── run.sh
├── saved_image_generators.swift
└── util.swift

1 directory, 10 files

--- Source File Contents ---

**** image_generators.swift ****************************************************
//
//  image_generators.swift
//  genimg
//
//  Created by Michael Teter on 2025-03-30.
//

import CoreGraphics

//func generatorTemplate(_ gc: CGContext) {
//  let canvasWidth = CGFloat(gc.width)
//  let canvasHeight = CGFloat(gc.height)
//
//  gc.saveGState()
//  solidBackground(gc: gc, color: makeColor(r: 20, g: 20, b: 30)) // Dark background
//  let selectedPalette = Palettes.all.randomElement()!
//  var previousColor = selectedPalette.randomElement()!
//
//  // do the drawing here
//  
//  gc.restoreGState()
//}

// Assumes the following functions/types are available from previous artifacts:
// - generateImperfectCirclePoints(center:radius:numPoints:maxOffsetMagnitude:startAngleDegrees:arcDegrees:) -> [CGPoint] [cite: imperfect_circle_points_degrees]
// - Palettes.all -> [[CGColor]] [cite: color.swift]
// - chance(_:) -> Bool [cite: util.swift]
// - complement(_:) -> CGColor [cite: color.swift]
// - adjustLightness(of:by:) -> CGColor? [cite: color.swift]
// - grayTone(_:strength:) -> CGColor? [cite: gray_tone_function]
// - drawCircle(gc:center:radius:lineWidth:strokeColor:solid:fillColor:) [cite: draw_circle_swift]
// - drawRotatedRect(gc:rect:center:rotation:lineWidth:strokeColor:solid:fillColor:) [cite: draw_swift_updated_rotation]
// - randCFloat(in:bias:biasStrengthBase:) -> CGFloat [cite: biased_random_cfloat] // Use the 'in range' version
// - RotationSpecification enum [cite: draw_swift_updated_rotation]
// - MathUtils.radToDeg(_:) -> CGFloat [cite: degree_radian_conversion]

/**
 Draws elements (circles or rectangles) along an imperfect circular path within a larger concentric structure.
 
 - Parameters:
 - gc: The graphics context.
 - palette: The color palette to use.
 - center: The center of the main circular path.
 - radius: The radius of the main circular path for this ring.
 - startAngleDegrees: Starting angle for the arc.
 - arcDegrees: Angular length of the arc.
 - pointCircleMaxRadius: The maximum radius/dimension for the small elements (circles/rects) drawn on this path.
 This value should ideally be pre-scaled based on the main path radius.
 - rects: If true, draw rectangles instead of circles. Defaults to false.
 */
func impCirInner(
  _ gc: CGContext,
  palette: [CGColor],
  center: CGPoint,
  radius: CGFloat,
  startAngleDegrees: CGFloat,
  arcDegrees: CGFloat,
  pointCircleMaxRadius: CGFloat, // Assumes this is the *scaled* max size for this radius
  rects: Bool = true
) {
  // --- Calculate Number of Points ---
  // Base number of points proportional to radius, with randomness
  var numPoints = Int(radius / 1.5)
  let n = Int.random(in: 1...100)
  if n <= 10 {
    numPoints = Int(Double(numPoints) * 2.5) // Increase more
  } else if n <= 25 { // Increase chance/amount
    numPoints *= 2
  } else if n > 95 { // Decrease chance
    numPoints = Int(Double(numPoints) / 1.5) // Decrease less
  }
  numPoints = max(10, numPoints) // Ensure a minimum number of points
  
  // --- Generate Points on Imperfect Path ---
  let pointWobbleMagnitude: CGFloat = 13.0 // How much points deviate from ideal circle
  let imperfectPoints = generateImperfectCirclePoints( // Assumes this exists [cite: imperfect_circle_points_degrees]
    center: center,
    radius: radius,
    numPoints: numPoints,
    maxOffsetMagnitude: pointWobbleMagnitude,
    startAngleDegrees: startAngleDegrees,
    arcDegrees: arcDegrees
  )
  
  guard !imperfectPoints.isEmpty else { return } // No points to draw
  
  // --- Initialize Color State ---
  var prevC: CGColor = palette.randomElement() ?? makeColor(r: 128, g: 128, b: 128) // Use gray if palette empty
  let changeColors: Bool = chance(5) // Decide upfront if colors will stick or change often
  
  // --- Draw Elements at Each Point ---
  let minElementSize: CGFloat = 3.0 // Minimum radius for circles / dimension for rects
  
  for point in imperfectPoints {
    // --- Color Logic ---
    var c: CGColor
    if changeColors {
      c = palette.randomElement() ?? prevC // Change color frequently
      prevC = c // Remember the newly picked color
    } else {
      c = chance(10) ? palette.randomElement() ?? prevC : prevC // Mostly stick to prevC
      // Don't update prevC here if sticking
    }
    
    var solid = false // Default to outline
    
    if chance(4) {
      c = complement(c)
      solid = true // Make complements solid
    }
    
    if chance(20) {
      c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... 0.5)) ?? c
    }
    
    if chance(10) {
      c = grayTone(c, strength: CGFloat.random(in: 0.1 ... 0.9)) ?? c
    }
    
    // --- Element Drawing ---
    if rects {
      // --- Draw Rectangle ---
      // Determine size based on the scaled max radius passed in
      // *** Use the 'in range:' version of randCFloat ***
      let rectW = randCFloat(
        in: minElementSize...pointCircleMaxRadius, // Use the pre-scaled max size
        bias: -0.5 // Slight bias towards smaller rects
      )
      // *** Use the 'in range:' version of randCFloat ***
      let rectH = randCFloat(
        in: minElementSize...pointCircleMaxRadius, // Use the pre-scaled max size
        bias: -0.5
      )
      
      // Make small rects more likely to be solid
      if max(rectW, rectH) <= 5 && chance(30) {
        solid = true
      }
      
      // Calculate rotation to be tangent to the main circle path + random offset
      let deltaX = point.x - center.x
      let deltaY = point.y - center.y
      // Avoid atan2(0,0) -> handle point being exactly at the center
      let angleToPointRad = (abs(deltaX) < 1e-6 && abs(deltaY) < 1e-6) ? 0.0 : atan2(deltaY, deltaX)
      let tangentAngleRad = angleToPointRad + .pi / 2.0 // Add 90 degrees for tangent
      let rotationSpec = RotationSpecification.randomDegrees(
        range: -10.0...10.0, // Small random wobble around tangent
        offsetRad: tangentAngleRad // Base offset is tangent angle
      )
      
      // Define the rectangle centered at the point *before* rotation is applied
      // drawRotatedRect handles the translation/rotation based on the rect's center
      let rect = CGRect(x: point.x - rectW / 2.0,
                        y: point.y - rectH / 2.0,
                        width: rectW,
                        height: rectH)
      
      drawRotatedRect( // Assumes this exists [cite: draw_swift_updated_rotation]
        gc: gc,
        rect: rect,
        rotation: rotationSpec,
        lineWidth: 1.0, // Use consistent line width
        strokeColor: c,
        solid: solid,
        fillColor: c
      )
      
    } else {
      // --- Draw Circle ---
      // *** Use the 'in range:' version of randCFloat ***
      let circleRadius = randCFloat(
        in: minElementSize...pointCircleMaxRadius, // Use the pre-scaled max size
        bias: -1.0, // Strong bias towards smaller circles
        biasStrengthBase: 5.0
      )
      // Make small circles more likely to be solid
      if circleRadius <= 4 && chance(30) {
        solid = true
      }
      
      drawCircle( // Assumes this exists [cite: draw_circle_swift]
        gc: gc,
        center: point,
        radius: circleRadius,
        lineWidth: 1.0, // Use consistent line width
        strokeColor: c,
        solid: solid,
        fillColor: c
      )
    }
  } // End loop through points
}

func impCirDemo(_ gc: CGContext) {
  let canvasWidth = CGFloat(gc.width)
  let canvasHeight = CGFloat(gc.height)
  
  gc.saveGState()
  let selectedPalette = Palettes.all.randomElement()!
  let baseBgColor = selectedPalette.randomElement()!
  let compBgColor = complement(baseBgColor)
  let finalBgColor = adjustLightness(of: compBgColor, by: -0.9)!
  solidBackground(gc: gc, color: finalBgColor) //makeColor(r: 20, g: 20, b: 25))

  let center = CGPoint(x: canvasWidth / 2.0, y: canvasHeight / 2.0)
  let startRadiusFactor: CGFloat = 0.02
  let endRadiusFactor: CGFloat = 0.45
  let steps: Int = 12
  let radiusGrowthRate: CGFloat = (endRadiusFactor - startRadiusFactor) / CGFloat(steps)
  
  let startRadius: CGFloat = min(canvasWidth, canvasHeight) * startRadiusFactor
  let endRadius: CGFloat = min(canvasWidth, canvasHeight) * endRadiusFactor

  let radiusCurvePower: CGFloat = 2.0 // Make point-circles grow slower at first (ease-in)

  let angleGap = chance(1) ? Int.random(in: 0...90) : 0
  let gapStart = Int.random(in: 0...359)
  var startAngle = CGFloat(gapStart + angleGap)
  var arcDegrees = CGFloat(360 - angleGap)

  for i in 0..<steps {
    let radiusFactor: CGFloat = startRadiusFactor + CGFloat(i) * radiusGrowthRate
    let radius: CGFloat = min(canvasWidth, canvasHeight) * radiusFactor

    // Calculate the radius for this specific path (linear interpolation for path radius is fine)
    let t = CGFloat(i) / CGFloat(max(1, steps - 1)) // Normalize i to 0..1
    let currentPathRadius = radius
    
    startAngle += CGFloat(10 + i)
    if (startAngle > 360.0) { startAngle -= 360.0 }
    
    // *** Calculate the scaled MAX radius for the point-circles on THIS path ***
    let currentMaxPointCircleRadius = calculateScaledValue(
      currentValue: currentPathRadius,
      minInputValue: startRadius,
      maxInputValue: endRadius,
      minTargetValue: 5.0,
      maxTargetValue: 18.0,
      curvePower: radiusCurvePower
    )
    
    impCirInner(
      gc,
      palette: selectedPalette,
      center: center,
      radius: radius,
      startAngleDegrees: startAngle,
      arcDegrees: arcDegrees,
      pointCircleMaxRadius: currentMaxPointCircleRadius
    )
  }
  
  gc.restoreGState()
}

/**
 Generates an image with shapes wandering across the canvas.
 Features include:
 - Wandering position with boundary avoidance.
 - Wandering rotation that builds on the previous angle with occasional resets.
 - Evolving color based on random palette changes, complements, lightness adjustments, and gray toning.
 - Random jumps in position.
 */
func wander(_ gc: CGContext) {
  let canvasWidth = CGFloat(gc.width)
  let canvasHeight = CGFloat(gc.height)
  
  // --- Configuration Parameters ---
  let numSteps = 40000
  // Position Wandering
  let minX: CGFloat = 0.0
  let maxX = canvasWidth
  let minY: CGFloat = 0.0
  let maxY = canvasHeight
  let pointMaxOffset = Int.random(in: 10...40) // Base step size range for position
  let pointBoundaryInfluence: CGFloat = 0.45 // How close to edge bias starts (40%)
  let pointBiasPower: CGFloat = 2.0 // How strongly bias pushes from edge (quadratic)
  let positionJumpChance: Double = 0.2 // 0.2% chance to jump to a new random location
  // Rotation Wandering
  let baseRotationRangeDeg: ClosedRange<CGFloat> = -5.0...5.0 // Small random delta each step
  let rotationResetChance: Double = 5.0 // 5% chance to reset rotation memory
  // Shape
  let minRectWidth: CGFloat = 3.0
  let maxRectWidth: CGFloat = 12.0
  let squareChance: Double = 95.0 // Chance rect height = width
  let smallSquareSolidChance: Double = 25.0 // Chance small squares (<=5x5) are solid
  let lineWidth: CGFloat = 1.0
  // Color Evolution
  let colorChangeChance: Double = 5.0 // Chance to pick new color from palette
  let complementChance: Double = 5.0 // Chance to use complement color
  let lightnessAdjustChance: Double = 50.0 // Chance to adjust lightness if not complement
  let grayToneChance: Double = 10.0 // Chance to mix with gray
  
  // --- Preparation ---
  gc.saveGState()
  solidBackground(gc: gc, color: makeColor(r: 20, g: 20, b: 30)) // Dark background
  
  // Select Palette
  let allPalettes = Palettes.all
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[wander] Could not select a valid random palette.")
    gc.restoreGState()
    return
  }
  guard var previousColor = selectedPalette.randomElement() else {
    printError("[wander] Selected palette is empty.")
    gc.restoreGState()
    return
  }
  
  
  // --- State Variables ---
  var currentX = CGFloat.random(in: minX...maxX)
  var currentY = CGFloat.random(in: minY...maxY)
  var previousRotationInRadians: CGFloat = 0.0 // Start with no rotation
  
  // --- Main Loop ---
  print("[wander] Starting wandering process for \(numSteps) steps...")
  for step in 1...numSteps {
    // 1. Position Update
    if chance(positionJumpChance) {
      // Randomly jump to a new location
      currentX = CGFloat.random(in: minX...maxX)
      currentY = CGFloat.random(in: minY...maxY)
      // Optional: Reset rotation on jump?
      // previousRotationInRadians = 0.0
    } else {
      // Wander smoothly using biased offset
      currentX = nextPointV(
        prevV: currentX, minV: minX, maxV: maxX,
        maxAbsOffset: pointMaxOffset, influenceRatio: pointBoundaryInfluence, power: pointBiasPower
      )
      currentY = nextPointV(
        prevV: currentY, minV: minY, maxV: maxY,
        maxAbsOffset: pointMaxOffset, influenceRatio: pointBoundaryInfluence, power: pointBiasPower
      )
    }
    
    // 2. Rotation Update (Wandering Rotation)
    let rotationSpec: RotationSpecification
    if chance(rotationResetChance) {
      // Reset rotation memory
      rotationSpec = .randomDegrees(range: baseRotationRangeDeg, offsetDeg: nil, offsetRad: nil)
      if step > 1 { print("Step \(step): Rotation Reset!") } // Avoid logging on first step
    } else {
      // Apply previous rotation as offset to the new random delta
      rotationSpec = .randomDegrees(range: baseRotationRangeDeg, offsetRad: previousRotationInRadians)
    }
    // Calculate the actual angle for this step (needed to update state)
    let currentRotationInRadians = rotAngle(rotationSpec)
    // Update state for *next* iteration
    previousRotationInRadians = currentRotationInRadians
    
    // 3. Shape and Size
    let rectW = CGFloat.random(in: minRectWidth...maxRectWidth)
    let rectH = chance(squareChance) ? rectW : CGFloat.random(in: minRectWidth...maxRectWidth)
    var solid = false
    if rectW == rectH && rectW <= 5 && chance(smallSquareSolidChance) {
      solid = true
    }
    
    // 4. Color Evolution
    var currentColor = previousColor
    if chance(colorChangeChance) {
      currentColor = selectedPalette.randomElement() ?? currentColor // Pick new from palette
    }
    
    if chance(complementChance) {
      currentColor = complement(currentColor)
      currentColor = adjustLightness(of: currentColor, by: CGFloat.random(in: -0.5 ... -0.1)) ?? currentColor
      // solid = true // Optional: make complements always solid?
    } else if chance(lightnessAdjustChance) {
      currentColor = adjustLightness(of: currentColor, by: CGFloat.random(in: -1.0...0.0)) ?? currentColor
    }
    
    if chance(grayToneChance) {
      currentColor = grayTone(currentColor, strength: CGFloat.random(in: 0.1 ... 0.9)) ?? currentColor
    }
    previousColor = currentColor // Remember color for next iteration
    
    
    // 5. Drawing
    let drawRect = CGRect(x: currentX - rectW / 2.0, // Center the rect on currentX/Y
                          y: currentY - rectH / 2.0,
                          width: rectW,
                          height: rectH)
    
    drawRotatedRect(gc: gc,
                    rect: drawRect,
                    rotation: rotationSpec, // Pass the calculated spec
                    lineWidth: lineWidth,
                    strokeColor: currentColor, // Use same color for stroke and fill
                    solid: solid,
                    fillColor: currentColor)
    
  } // End loop
  
  gc.restoreGState()
}


//func wander(_ gc: CGContext) {
//  let canvasWidth = gc.width
//  let canvasHeight = gc.height
//  
//  // --- Preparation ---
//  gc.saveGState() // Save the clean state
//  
//  // 1. Randomly select one palette
//  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
//  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
//    printError("[Error in do_basic] Could not select a valid random palette.")
//    gc.restoreGState() // Restore state before exiting
//    return
//  }
// 
//  var prevColor = selectedPalette.randomElement()!
//
//  solidBackground(gc: gc)
//  
//  let minX: CGFloat = 0.0
//  let maxX = CGFloat(canvasWidth)
//  let minY: CGFloat = 0.0
//  let maxY = CGFloat(canvasHeight)
//  
//  var prevX = CGFloat.random(in: minX...maxX)
//  var prevY = CGFloat.random(in: minY...maxY)
//
//  let maxOffset = Int.random(in: 10...40)
//  
//  let boundaryInfluence: CGFloat = 0.4 // effect active within 5% of edge
//  let biasPower: CGFloat = 0.5 // cubic bias - stronger effect near walls
//  
//  let maxRotDeg = CGFloat.random(in: 0...8)
//  var lastRotRad = 0.0
//  
//  for _ in 0..<40000 {
//    if (chance(0.2)) {
//      prevX = CGFloat.random(in: minX...maxX)
//      prevY = CGFloat.random(in: minY...maxY)
//    }
//    
//    let x = nextPointV(
//      prevV: prevX,
//      minV: minX,
//      maxV: maxX,
//      maxAbsOffset: maxOffset,
//      influenceRatio: boundaryInfluence,
//      power: biasPower
//    )
//    
//    let y = nextPointV(
//      prevV: prevY,
//      minV: minY,
//      maxV: maxY,
//      maxAbsOffset: maxOffset,
//      influenceRatio: boundaryInfluence,
//      power: biasPower
//    )
//
//    prevX = x
//    prevY = y
//    
//    let upperRadius = chance(5) ? 12.0 : 8.0
////    let radius = CGFloat.random(in: 2...9)
//    let radius = CGFloat.random(in: 2...upperRadius)
////    let radius = 10.0
//    
//    var c: CGColor = prevColor
//    var solid: Bool = false
//    
////    if (radius <= 3) { solid = true }
//    
//    if (chance(5)) {
//      c = selectedPalette.randomElement()!
//    }
//    
//    if (chance(5)) {
//      c = complement(c)
//      c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... -0.1)) ?? c
////      solid = true
//    } else {
//      if (chance(50)) {
//        c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
//      }
//    }
//    
//    if (chance(10)) {
//      c = grayTone(c, strength: CGFloat.random(in: 0.0 ... 1.0)) ?? c
//    }
//    
////    solid = chance(5) ? true : solid
//    
//    prevColor = c
//    
//    let lineWidth: CGFloat = 1.0 // Or random
//        
//    let rectW = CGFloat.random(in: 3...12)
//    let rectH = chance(5) ? CGFloat.random(in: 3...12) : rectW // usually square
//
//    if (rectW == rectH && rectW <= 5 && chance(25)) { solid = true }
//    
//    let rotSpec: RotationSpecification
//
//    if (chance(5)) {
//      rotSpec = .none
//      lastRotRad = 0.0
//    } else {
//      rotSpec = RotationSpecification.randomDegrees(range: -5 ... 5)
//      
////    if (chance(90)) {
////      rotSpec = RotationSpecification.randomDegrees(range: -maxRotDeg...maxRotDeg)
////    } else {
////      rotSpec = .none
////    }
//
//    drawRotatedRect(gc: gc,
//                    rect: CGRect(x: x - rectW / 2.0,
//                                 y: y - rectH / 2.0,
//                                 width: rectW,
//                                 height: rectH),
//                    rotation: rotSpec,
//                    lineWidth: lineWidth, strokeColor: c,
//                    solid: solid, fillColor: c)
//                    
//    
////    drawRect(gc: gc,
////             rect: CGRect(x: x - rectW / 2.0,
////                          y: y - rectH / 2.0,
////                          width: rectW,
////                          height: rectH),
////             lineWidth: lineWidth, strokeColor: c,
////             solid: solid, fillColor: c)
////    drawCircle(
////      gc: gc,
////      center: CGPoint(x: x, y: y),
////      radius: radius,
////      lineWidth: lineWidth,
////      strokeColor: c,
////      solid: solid,
////      fillColor: c
////    )
//  }
//  
//  gc.restoreGState() // Restore to the clean state saved at the beginning
//}


func rectLanes(_ gc: CGContext) {
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  let nYZones: Int = Int.random(in: 1...20)
  let yZones = lineZones(maxV: gc.height, nLines: nYZones, fuzziness: 0.01)
  
  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  solidBackground(gc: gc)
  
//  let maxRotDeg: CGFloat = CGFloat.random(in: 1...8)
  
  let yZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)
  let maxYOffset = CGFloat(canvasHeight) / (CGFloat(nYZones) * yZoneOverlap)
  
  let xZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)
  
  for zoneY in yZones {
    let thinOut: Int = Int.random(in: 0...20) // Thin out up to 20%
    let globalDim: CGFloat = CGFloat.random(in: -0.4 ... 0.2)
    let compEverything: Bool = chance(22)
    
    let nXZones: Int = nYZones // Int.random(in: 1...20)
    let xZones = lineZones(maxV: gc.width, nLines: nXZones, fuzziness: 0.01)
    
    //    let xZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)
    let maxXOffset = CGFloat(canvasWidth) / (CGFloat(nXZones) * xZoneOverlap)
    
    let maxRotDeg: CGFloat = CGFloat.random(in: 40...50)

    for zoneX in xZones {
      let xIterations = 50000 / (nXZones * nYZones)
      
      for _ in 0..<xIterations {
        if chance(thinOut) { continue }
        
        guard let randomColor = selectedPalette.randomElement() else { continue }
        
        // 1. Define Position and Size (e.g., randomly)
        var rectWidth = CGFloat.random(in: 3...20)
        var rectHeight = CGFloat.random(in: 3...20)
        var radius = CGFloat.random(in: 3...8)
        let xOffset = CGFloat.random(in: -maxXOffset ... maxXOffset)
        let yOffset = CGFloat.random(in: -maxYOffset ... maxYOffset)
        let rectX: CGFloat = (zoneX + xOffset) - rectWidth / 2.0
        let rectY: CGFloat = (zoneY + yOffset) - rectHeight / 2.0
        
        var c: CGColor = randomColor
        let solid: Bool = false
        
        if (!compEverything && chance(2)) {
          c = complement(randomColor)
          c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... -0.1)) ?? c
        } else {
          if (compEverything) {
            c = complement(c)
          }
          
          if (chance(50)) {
            c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
          }
        }
        
        if (chance(50)) {
          c = grayTone(c, strength: CGFloat.random(in: 0.0 ... 1.0)) ?? c
        }
        
        if (rectX + rectWidth >= CGFloat(canvasWidth)) {
          rectWidth = CGFloat(canvasWidth) - rectX - 1
        }
        
        if (rectY + rectHeight >= CGFloat(canvasHeight)) {
          rectHeight = CGFloat(canvasHeight) - rectY - 1
        }
        
        let rotSpec: RotationSpecification
        
        if (chance(90)) {
          rotSpec = RotationSpecification.randomDegrees(range: -maxRotDeg...maxRotDeg)
        } else {
          rotSpec = .none
        }
        
        let lineWidth: CGFloat = 1.0 // Or random
        
        let rect = CGRect(origin: CGPoint(x: rectX, y: rectY),
                          size: CGSize(width: rectWidth, height: rectHeight))
        
        c = adjustLightness(of: c, by: globalDim) ?? c
        
        drawCircle(
          gc: gc,
          center: CGPoint(x: rectX + (rectWidth / 2.0), y: rectY + (rectHeight / 2.0)),
          radius: radius,
          lineWidth: lineWidth,
          strokeColor: c,
          solid: solid,
          fillColor: c
        )
//        drawRotatedRect(gc: gc,
//                        rect: rect, // center: CGPoint? = nil, // Make center optional
//                        rotation: rotSpec,
//                        lineWidth: lineWidth, strokeColor: c,
//                        solid: solid, fillColor: c)
      }
    }
  }
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}

func rectLanes1(_ gc: CGContext) {
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  let nYZones: Int = Int.random(in: 2...12)
  let yZones = lineZones(maxV: gc.height, nLines: nYZones, fuzziness: 0.1)

  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  solidBackground(gc: gc)
  
  let maxRotDeg: CGFloat = CGFloat.random(in: 1...6)
  
  let yZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)
  let maxYOffset = CGFloat(canvasHeight) / (CGFloat(nYZones) * yZoneOverlap)

  let xZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)

  for zoneY in yZones {
    let thinOut: Int = Int.random(in: 0...20) // Thin out up to 20%
    let globalDim: CGFloat = CGFloat.random(in: -0.4 ... 0.2)
    let compEverything: Bool = chance(22)

    let nXZones: Int = Int.random(in: 2...12)
    let xZones = lineZones(maxV: gc.width, nLines: nXZones, fuzziness: 0.1)
    
//    let xZoneOverlap = CGFloat.random(in: 1.5 ... 3.0)
    let maxXOffset = CGFloat(canvasWidth) / (CGFloat(nXZones) * xZoneOverlap)

    for zoneX in xZones {
      let xIterations = 200000 / (nXZones * nYZones)
      
      for _ in 0..<xIterations {
        if chance(thinOut) { continue }
        
        guard let randomColor = selectedPalette.randomElement() else { continue }
        
        // 1. Define Position and Size (e.g., randomly)
        var rectWidth = CGFloat.random(in: 3...12)
        var rectHeight = CGFloat.random(in: 3...12)
        let xOffset = CGFloat.random(in: -maxXOffset ... maxXOffset)
        let yOffset = CGFloat.random(in: -maxYOffset ... maxYOffset)
        let rectX: CGFloat = (zoneX + xOffset) - rectWidth / 2.0
        let rectY: CGFloat = (zoneY + yOffset) - rectHeight / 2.0
        
        var c: CGColor = randomColor
        let solid: Bool = false
        
        if (!compEverything && chance(2)) {
          c = complement(randomColor)
          c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... -0.1)) ?? c
        } else {
          if (compEverything) {
            c = complement(c)
          }
          
          if (chance(50)) {
            c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
          }
        }
        
        if (rectX + rectWidth >= CGFloat(canvasWidth)) {
          rectWidth = CGFloat(canvasWidth) - rectX - 1
        }
        
        if (rectY + rectHeight >= CGFloat(canvasHeight)) {
          rectHeight = CGFloat(canvasHeight) - rectY - 1
        }
        
        let rotSpec: RotationSpecification
        
        if (Int.random(in: 1...100) < 10) {
          rotSpec = RotationSpecification.randomDegrees(range: -maxRotDeg...maxRotDeg)
        } else {
          rotSpec = .none
        }
        
        let lineWidth: CGFloat = 1.0 // Or random
        
        let rect = CGRect(origin: CGPoint(x: rectX, y: rectY),
                          size: CGSize(width: rectWidth, height: rectHeight))
        
        c = adjustLightness(of: c, by: globalDim) ?? c
        
        drawRotatedRect(gc: gc,
                        rect: rect, // center: CGPoint? = nil, // Make center optional
                        rotation: rotSpec,
                        lineWidth: lineWidth, strokeColor: c,
                        solid: solid, fillColor: c)
      }
    }
  }
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}

func rectLanes0(_ gc: CGContext) {
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  let nZones: Int = Int.random(in: 2...12)
  let hZones = lineZones(maxV: gc.height, nLines: nZones, fuzziness: 0.1)
  
  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  solidBackground(gc: gc)
  
  let maxRotDeg: CGFloat = CGFloat.random(in: 1...6)
  
  let maxYOffset = CGFloat(canvasHeight) / CGFloat(nZones) * 0.4 / 2.0
  
  let iterations = 40000 / nZones
  
  for zoneY in hZones {
    let thinOut: Int = Int.random(in: 0...20) // Thin out up to 20%
    let globalDim: CGFloat = CGFloat.random(in: -0.4 ... 0.2)
    let compEverything: Bool = chance(22)
    
    for _ in 0..<iterations {
      if chance(thinOut) { continue }
      
      guard let randomColor = selectedPalette.randomElement() else { continue }
      
      // 1. Define Position and Size (e.g., randomly)
      var rectWidth = CGFloat.random(in: 3...12)
      var rectHeight = CGFloat.random(in: 3...12)
      let yOffset = CGFloat.random(in: -maxYOffset ... maxYOffset)
      let rectX = CGFloat.random(in: 0...(CGFloat(canvasWidth) - rectWidth))
      let rectY: CGFloat = (zoneY + yOffset) - rectHeight / 2.0
      
      var c: CGColor = randomColor
      let solid: Bool = false
      
      if (!compEverything && chance(2)) {
        c = complement(randomColor)
        c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... -0.1)) ?? c
      } else {
        if (compEverything) {
          c = complement(c)
        }
        
        if (chance(50)) {
          c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
        }
      }
      
      if (rectX + rectWidth >= CGFloat(canvasWidth)) {
        rectWidth = CGFloat(canvasWidth) - rectX - 1
      }
      
      if (rectY + rectHeight >= CGFloat(canvasHeight)) {
        rectHeight = CGFloat(canvasHeight) - rectY - 1
      }
      
      let rotSpec: RotationSpecification
      
      if (Int.random(in: 1...100) < 10) {
        rotSpec = RotationSpecification.randomDegrees(range: -maxRotDeg...maxRotDeg)
      } else {
        rotSpec = .none
      }
      
      let lineWidth: CGFloat = 1.0 // Or random
      
      let rect = CGRect(origin: CGPoint(x: rectX, y: rectY),
                        size: CGSize(width: rectWidth, height: rectHeight))
      
      c = adjustLightness(of: c, by: globalDim) ?? c
      
      drawRotatedRect(gc: gc,
                      rect: rect, // center: CGPoint? = nil, // Make center optional
                      rotation: rotSpec,
                      lineWidth: lineWidth, strokeColor: c,
                      solid: solid, fillColor: c)
    }
  }
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}

func do_basic_rot(_ gc: CGContext) {
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  solidBackground(gc: gc)
  
  let maxRotDeg: CGFloat = CGFloat.random(in: 1...6)
  
  for _ in 0..<10000 {
    guard let randomColor = selectedPalette.randomElement() else { continue }

    // 1. Define Position and Size (e.g., randomly)
    var rectWidth = CGFloat.random(in: 3...200)
    var rectHeight = CGFloat.random(in: 3...10)
    // Ensure top-left choice keeps the rectangle roughly in bounds initially
    let rectX = CGFloat.random(in: 0...(CGFloat(canvasWidth) - rectWidth))
    let rectY = CGFloat.random(in: 0...(CGFloat(canvasHeight) - rectHeight))
    
    // Choose color
    var c: CGColor = randomColor
    var solid: Bool = false
    
    if (chance(2)) {
      c = complement(randomColor)
      c = adjustLightness(of: c, by: CGFloat.random(in: -0.5 ... -0.1)) ?? c
      if (chance(50)) {
        solid = true
        swap(&rectWidth, &rectHeight)
      }
    } else {
      if (chance(50)) {
        c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
      }
    }
    
    if (rectX + rectWidth >= CGFloat(canvasWidth)) {
      rectWidth = CGFloat(canvasWidth) - rectX - 1
    }

    if (rectY + rectHeight >= CGFloat(canvasHeight)) {
      rectHeight = CGFloat(canvasHeight) - rectY - 1
    }

    let rotSpec: RotationSpecification
    
    if (Int.random(in: 1...100) < 10) {
      rotSpec = RotationSpecification.randomDegrees(range: -maxRotDeg...maxRotDeg)
    } else {
      rotSpec = .none
    }
        
    let lineWidth: CGFloat = 1.0 // Or random
    
    let rect = CGRect(origin: CGPoint(x: rectX, y: rectY),
                      size: CGSize(width: rectWidth, height: rectHeight))
    
    drawRotatedRect(gc: gc,
                    rect: rect, // center: CGPoint? = nil, // Make center optional
                    rotation: rotSpec,
                    lineWidth: lineWidth, strokeColor: c,
                    solid: solid, fillColor: c)
  }

  gc.restoreGState() // Restore to the clean state saved at the beginning
}

func do_basic(_ gc: CGContext) {
  // Get canvas dimensions from the context
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  print("[Info] Using palette with \(selectedPalette.count) colors.")
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  gc.setFillColor(CGColor(gray: 0.0, alpha: 1.0)) // Black
  gc.fill(CGRect(x: 0, y: 0, width: canvasWidth, height: canvasHeight))
  
  // Set a default line width for the rectangles
  gc.setLineWidth(1.0) // Adjust as needed
  
  // --- Drawing Loop ---
  // 2. Loop 100 times
  for i in 0..<6000 {
    // 2.1 Randomly select a color from the chosen palette
    guard let randomColor = selectedPalette.randomElement() else {
      // This should ideally not happen if the initial palette check passed
      printError("[Warning in do_basic] Selected palette became empty during loop? Skipping iter \(i).")
      continue
    }
    
    var c: CGColor = randomColor
    
    if (Int.random(in: 1...100) <= 2) {
      c = complement(randomColor)
    }
    if (Int.random(in: 1...100) <= 20) {
      c = adjustLightness(of: c, by: CGFloat.random(in: -1.0...0.0)) ?? c
    }
    gc.setStrokeColor(c) // Set the outline color
    
    // 2.2 Define a random rectangle
    var minW: CGFloat
    var minH: CGFloat
    var maxW: CGFloat
    var maxH: CGFloat
    if (Int.random(in: 1...10) < 2) {
      minW = 3.0
      maxW = 5.0
      minH = 80.0
      maxH = 100.0
    } else {
      minW = 80.0
      maxW = 200.0
      minH = 1.0
      maxH = 1.0
    }
    let rectWidth = CGFloat.random(in: minW...maxW)
    let rectHeight = CGFloat.random(in: minH...maxH)
    
    // Ensure x/y coordinates keep the rectangle within bounds
    let rectX = CGFloat.random(in: 0...(CGFloat(canvasWidth) - rectWidth))
    let rectY = CGFloat.random(in: 0...(CGFloat(canvasHeight) - rectHeight))
    
    let randomRect = CGRect(x: rectX, y: rectY, width: rectWidth, height: rectHeight)
    
    // 2.3 Draw the rectangle outline (stroke)
    gc.stroke(randomRect)
  }
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}

/**
 Generates a list of x or y coordinates for lines, with added random variation.
 
 - Parameters:
 - gc: The graphics context, used to get the canvas dimensions.
 - orientation:  An enum indicating the orientation of the lines: `.horizontal` or `.vertical`.
 - nLines: The number of lines to generate.
 - fuzziness: The maximum random variation, as a percentage of the ideal line spacing (default: 0.1).
 
 - Returns: An array of CGFloat values representing the y-coordinates (for horizontal lines)
 or x-coordinates (for vertical lines) of the lines.  Returns an empty array on error.
 */
func lineZones(minV: Int = 0, maxV: Int, nLines: Int, fuzziness: CGFloat = 0.1) -> [CGFloat] {
  lineZones(minV: CGFloat(minV), maxV: CGFloat(maxV), nLines: nLines, fuzziness: fuzziness)
}

func lineZones(minV: CGFloat = 0, maxV: CGFloat, nLines: Int, fuzziness: CGFloat = 0.1) -> [CGFloat] {
  let length = maxV - minV
  
  let idealSpacing = length / CGFloat(nLines + 1) // Space before first, between, and after last line.
  let maxFuzz = idealSpacing * fuzziness
  
  var linePositions: [CGFloat] = []
  
  for i in 1...nLines {
    // Calculate the ideal position for the line
    let idealPosition = CGFloat(i) * idealSpacing
    
    // Generate a random offset (fuzz)
    let fuzz = CGFloat.random(in: -maxFuzz...maxFuzz)
    
    // Apply the offset to get the final line position
    let linePosition = idealPosition + fuzz + minV
    
    // Ensure the line position is within the canvas bounds
    let boundedPosition = max(minV, min(linePosition, maxV))
    
    linePositions.append(boundedPosition)
  }
  
  return linePositions
}

func colorTest(_ gc: CGContext) {
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  gc.saveGState() // Save the clean state
  
  //  // 1. Select the specific palette (e.g., 'orig')
  //  let selectedPalette = Palettes.orig // Or change to Palettes.hokusai, etc.
  //  guard !selectedPalette.isEmpty else {
  //    printError("[Error in do_basic] The selected palette ('orig') is empty.")
  //    gc.restoreGState()
  //    return
  //  }
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  
  let nColors = selectedPalette.count
  
  // 2. Define the number of shades per color and calculate rect width
  let nShades = 5 // The original color + 4 darker shades
  
  // Calculate width for each individual shade bar
  let rectW = CGFloat(canvasWidth) / CGFloat(nColors * nShades)
  
  // Optional: Clear background (e.g., to white)
  gc.setFillColor(CGColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)) // White
  gc.fill(CGRect(x: 0, y: 0, width: canvasWidth, height: canvasHeight))
  
  // --- Drawing Loops ---
  var currentX: CGFloat = 0.0 // Keep track of the horizontal position
  
  // Outer loop: Iterate through each color in the selected palette
  for originalColor in selectedPalette {
    
    // Inner loop: Iterate 5 times for the 5 shades (0% to 80% darker)
    for stepNum in 0..<nShades { // stepNum will be 0, 1, 2, 3, 4
      
      // Calculate the darkening percentage (0.0, -0.2, -0.4, -0.6, -0.8)
      let darknessPercentage = -CGFloat(stepNum) * 0.20
      
      // Determine the color for this shade bar
      var currentColor: CGColor
      if stepNum == 0 {
        // First bar uses the original color
        currentColor = originalColor
      } else {
        // Subsequent bars use darkened versions
        // Use Palettes.adjustLightness, provide fallback if it returns nil
        currentColor = adjustLightness(of: originalColor, by: darknessPercentage) ?? originalColor
      }
      
      // Define the rectangle for this shade bar
      let rect = CGRect(x: currentX, y: 0, width: rectW, height: CGFloat(canvasHeight))
      
      // Set the fill color (no need to set stroke separately if filling)
      gc.setFillColor(currentColor)
      
      // Fill the rectangle
      gc.fill(rect)
      
      // Update the x position for the next rectangle
      currentX += rectW
    } // End inner loop (shades)
  } // End outer loop (palette colors)
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}

/**
 Generates an image visualizing all available palettes in a grid.
 Each palette is shown in a cell, with its colors displayed as vertical bars.
 
 - Parameter gc: The graphics context to draw into.
 */
func demoPalettes(_ gc: CGContext) {
  let canvasWidth = CGFloat(gc.width)
  let canvasHeight = CGFloat(gc.height)
  let palettes = Palettes.all // Get all palettes [cite: color.swift]
  
  guard !palettes.isEmpty else {
    printError("[demoPalettes] No palettes found in Palettes.all.")
    // Optionally draw an error message on the canvas
    solidBackground(gc: gc, color: makeColor(r: 50, g: 0, b: 0)) // Dark red background
    // TODO: Add text drawing function here if desired
    return
  }
  
  let numPalettes = palettes.count
  
  // --- Calculate Grid Dimensions ---
  // Determine the number of columns and rows for the grid
  // Aim for a layout close to a square
  let colsDouble = ceil(sqrt(Double(numPalettes)))
  let rowsDouble = ceil(Double(numPalettes) / colsDouble)
  let cols = Int(colsDouble)
  let rows = Int(rowsDouble)
  
  // Calculate the size of each grid cell
  let cellWidth = canvasWidth / CGFloat(cols)
  let cellHeight = canvasHeight / CGFloat(rows)
  
  // Define padding around the color bars within each cell
  let padding: CGFloat = 4.0 // Adjust padding as needed
  
  print("[demoPalettes] Creating a \(cols)x\(rows) grid for \(numPalettes) palettes.")
  print("[demoPalettes] Cell size: \(cellWidth)w x \(cellHeight)h")
  
  // --- Clear Background ---
  gc.saveGState()
  solidBackground(gc: gc, color: makeColor(r: 255, g: 255, b: 255)) // White background
  
  // --- Iterate Through Palettes and Draw ---
  for (index, palette) in palettes.enumerated() {
    guard !palette.isEmpty else {
      print("[demoPalettes] Skipping empty palette at index \(index).")
      continue // Skip empty palettes
    }
    
    // Calculate the row and column for the current palette's cell
    let row = index / cols
    let col = index % cols
    
    // Calculate the top-left corner of the cell
    let cellX = CGFloat(col) * cellWidth
    let cellY = CGFloat(row) * cellHeight
    
    // Calculate the drawable area within the cell (applying padding)
    let drawableX = cellX + padding / 2.0
    let drawableY = cellY + padding / 2.0
    let drawableWidth = cellWidth - padding
    let drawableHeight = cellHeight - padding
    
    guard drawableWidth > 0 && drawableHeight > 0 else {
      print("[demoPalettes] Cell size too small for padding at index \(index). Skipping.")
      continue
    }
    
    let numColors = palette.count
    // Calculate the height of each vertical color segment
    let segmentHeight = drawableHeight / CGFloat(numColors)
    
    // Draw each color in the palette as a vertical segment
    for (colorIndex, color) in palette.enumerated() {
      let segmentY = drawableY + CGFloat(colorIndex) * segmentHeight
      
      // Define the rectangle for this color segment
      let rect = CGRect(x: drawableX,
                        y: segmentY,
                        width: drawableWidth,
                        height: segmentHeight)
      
      // Draw the filled rectangle using the function from draw.swift [cite: draw.swift]
      // Assumes drawRect handles solid fill correctly without needing stroke parameters.
      drawRect(gc: gc,
               rect: rect,
               solid: true,
               fillColor: color)
    }
    // Optional: Draw a border around the cell for clarity
    let cellRect = CGRect(x: cellX, y: cellY, width: cellWidth, height: cellHeight)
    drawRect(gc: gc, rect: cellRect, lineWidth: 0.5, strokeColor: makeColor(r: 150, g: 150, b: 150)) // Light gray border
    
  } // End loop through palettes
  
  gc.restoreGState()
  print("[demoPalettes] Finished drawing palette visualization.")
}

/**
 Generates a list of points forming an imperfect circle, accepting angles in degrees.
 
 This is an overload that converts degree inputs to radians and calls the
 primary radian-based `generateImperfectCirclePoints` function.
 
 - Parameters:
 - center: The center point of the ideal circle.
 - radius: The radius of the ideal circle. Must be positive.
 - numPoints: The number of points to generate along the circumference. Must be positive.
 - maxOffsetMagnitude: The maximum random offset applied to both x and y
 coordinates at each point. Must be non-negative.
 - startAngleDegrees: The starting angle in **degrees** (0 is typically the rightmost point). Defaults to 0.
 - arcDegrees: The total angle **in degrees** to cover (e.g., 360 for a full circle). Defaults to 360.
 - Returns: An array of `CGPoint` representing the imperfect circle points. Returns an empty array if inputs are invalid (checked by the radian version).
 */
func generateImperfectCirclePoints(
  center: CGPoint,
  radius: CGFloat,
  numPoints: Int,
  maxOffsetMagnitude: CGFloat,
  startAngleDegrees: CGFloat = 0.0,
  arcDegrees: CGFloat = 360.0 // Default to full circle in degrees
) -> [CGPoint] {
  
  // 1. Convert degree inputs to radians using the utility function [cite: degree_radian_conversion]
  let startAngleRadians = MathUtils.degToRad(startAngleDegrees)
  // Note: degToRad works correctly for arc length conversion as well (factor is pi/180)
  let arcRadians = MathUtils.degToRad(arcDegrees)
  
  // 2. Call the original radian-based function
  return generateImperfectCirclePoints(
    center: center,
    radius: radius,
    numPoints: numPoints,
    maxOffsetMagnitude: maxOffsetMagnitude,
    startAngleRadians: startAngleRadians, // Pass converted start angle
    arcRadians: arcRadians // Pass converted arc length
  )
}

/**
 Generates a list of points forming an imperfect circle.
 
 Points are calculated by stepping around an ideal circle and adding a
 random offset to the x and y coordinates at each step. The base position
 for each step is always calculated from the ideal circle, preventing
 error accumulation.
 
 - Parameters:
 - center: The center point of the ideal circle.
 - radius: The radius of the ideal circle. Must be positive.
 - numPoints: The number of points to generate along the circumference. Must be positive.
 - maxOffsetMagnitude: The maximum random offset applied to both x and y
 coordinates at each point. A value of 0 results in points
 lying perfectly on the circle. Must be non-negative.
 - startAngleRadians: The starting angle in radians (0 is typically the rightmost point). Defaults to 0.
 - arcRadians: The total angle in radians to cover (e.g., 2 * .pi for a full circle). Defaults to a full circle.
 - Returns: An array of `CGPoint` representing the imperfect circle points. Returns an empty array if inputs are invalid.
 */
func generateImperfectCirclePoints(
  center: CGPoint,
  radius: CGFloat,
  numPoints: Int,
  maxOffsetMagnitude: CGFloat,
  startAngleRadians: CGFloat = 0.0,
  arcRadians: CGFloat = 2.0 * .pi
) -> [CGPoint] {
  
  // Input validation
  guard radius > 0, numPoints > 0, maxOffsetMagnitude >= 0 else {
    printError("[generateImperfectCirclePoints] Invalid input: radius (\(radius)), numPoints (\(numPoints)), or maxOffsetMagnitude (\(maxOffsetMagnitude)) must be positive/non-negative.")
    return []
  }
  
  var points: [CGPoint] = []
  points.reserveCapacity(numPoints) // Optimize allocation
  
  // Calculate the angular step between points
  // Avoid division by zero if numPoints is 1 (though guard prevents numPoints=0)
  let angleStep = (numPoints > 1) ? (arcRadians / CGFloat(numPoints)) : 0.0
  
  for i in 0..<numPoints {
    // 1. Calculate the ideal angle for this step
    let idealAngle = startAngleRadians + CGFloat(i) * angleStep
    
    // 2. Calculate the ideal point on the perfect circle
    let idealX = center.x + radius * cos(idealAngle)
    let idealY = center.y + radius * sin(idealAngle)
    
    // 3. Generate random offsets
    let offsetX = CGFloat.random(in: -maxOffsetMagnitude...maxOffsetMagnitude)
    let offsetY = CGFloat.random(in: -maxOffsetMagnitude...maxOffsetMagnitude)
    
    // 4. Calculate the perturbed point by adding offsets
    let perturbedX = idealX + offsetX
    let perturbedY = idealY + offsetY
    let perturbedPoint = CGPoint(x: perturbedX, y: perturbedY)
    
    // 5. Store the point
    points.append(perturbedPoint)
  }
  
  return points
}


**** saved_image_generators.swift **********************************************
//
//  saved_image_generators.swift
//  genimg
//
//  Created by Michael Teter on 2025-03-30.
//

import CoreGraphics

func do_basic_20250330(_ gc: CGContext) {
  // Get canvas dimensions from the context
  let canvasWidth = gc.width
  let canvasHeight = gc.height
  
  // --- Preparation ---
  gc.saveGState() // Save the clean state
  
  // 1. Randomly select one palette
  let allPalettes = Palettes.all // Assumes Palettes.all is defined in Color.swift
  guard let selectedPalette = allPalettes.randomElement(), !selectedPalette.isEmpty else {
    printError("[Error in do_basic] Could not select a valid random palette.")
    gc.restoreGState() // Restore state before exiting
    return
  }
  print("[Info] Using palette with \(selectedPalette.count) colors.")
  
  // Optional: Clear background (e.g., to black) before drawing rectangles
  gc.setFillColor(CGColor(gray: 0.0, alpha: 1.0)) // Black
  gc.fill(CGRect(x: 0, y: 0, width: canvasWidth, height: canvasHeight))
  
  // Set a default line width for the rectangles
  gc.setLineWidth(1.0) // Adjust as needed
  
  // --- Drawing Loop ---
  // 2. Loop 100 times
  for i in 0..<10000 {
    // 2.1 Randomly select a color from the chosen palette
    guard let randomColor = selectedPalette.randomElement() else {
      // This should ideally not happen if the initial palette check passed
      printError("[Warning in do_basic] Selected palette became empty during loop? Skipping iter \(i).")
      continue
    }
    gc.setStrokeColor(randomColor) // Set the outline color
    
    // 2.2 Define a random rectangle
    let maxW: CGFloat
    let maxH: CGFloat
    if (Int.random(in: 1...2) == 1) {
      maxW = 10.0
      maxH = 100.0
    } else {
      maxW = 100.0
      maxH = 10.0
    }
    let rectWidth = CGFloat.random(in: 1...maxW)
    let rectHeight = CGFloat.random(in: 1...maxH)
    
    // Ensure x/y coordinates keep the rectangle within bounds
    let rectX = CGFloat.random(in: 0...(CGFloat(canvasWidth) - rectWidth))
    let rectY = CGFloat.random(in: 0...(CGFloat(canvasHeight) - rectHeight))
    
    let randomRect = CGRect(x: rectX, y: rectY, width: rectWidth, height: rectHeight)
    
    // 2.3 Draw the rectangle outline (stroke)
    gc.stroke(randomRect)
  }
  
  gc.restoreGState() // Restore to the clean state saved at the beginning
}


**** util.swift ****************************************************************
//
//  util.swift
//  genimg
//
//  Created by Michael Teter on 2025-03-29.
//

import Foundation // Needed for Date, DateFormatter
import AppKit // Import AppKit, which includes Core Graphics and is needed for NSImage later
import UniformTypeIdentifiers // Needed for UTType.png

/**
 Calculates a maximum radius value that scales non-linearly based on a current value's
 position within an input range.
 
 Useful for scaling visual properties (like the max size of detail elements)
 based on their position relative to a larger structure (like distance from center).
 
 - Parameters:
 - currentValue: The current input value (e.g., current path radius).
 - minInputValue: The minimum value of the input range (e.g., min path radius).
 - maxInputValue: The maximum value of the input range (e.g., max path radius).
 - minTargetValue: The target output value when currentValue equals minInputValue.
 - maxTargetValue: The target output value when currentValue equals maxInputValue.
 - curvePower: The exponent applied to the normalized input value to create
 non-linear scaling.
 - `curvePower == 1.0`: Linear scaling.
 - `curvePower > 1.0`: Ease-in scaling (starts slow, accelerates).
 - `0.0 < curvePower < 1.0`: Ease-out scaling (starts fast, decelerates).
 Defaults to 2.0 (quadratic ease-in).
 - Returns: The calculated scaled target value, clamped between minTargetValue and maxTargetValue.
 */
func calculateScaledValue(
  currentValue: CGFloat,
  minInputValue: CGFloat,
  maxInputValue: CGFloat,
  minTargetValue: CGFloat,
  maxTargetValue: CGFloat,
  curvePower: CGFloat = 2.0 // Default to quadratic ease-in
) -> CGFloat {
  
  // 1. Handle edge case: input range has zero width
  guard maxInputValue > minInputValue else {
    // Return the target value corresponding to the collapsed input range
    // Or average, or based on which bound currentValue matches, here we default to minTargetValue
    return minTargetValue
  }
  // Ensure curvePower is positive
  let power = max(0.001, curvePower) // Avoid zero or negative power
  
  // 2. Normalize the currentValue to a 0.0 - 1.0 range
  let normalizedValue = (currentValue - minInputValue) / (maxInputValue - minInputValue)
  // Clamp normalized value to handle inputs slightly outside the range
  let clampedNormalizedValue = max(0.0, min(1.0, normalizedValue))
  
  // 3. Apply the non-linear curve (power function)
  let curvedValue = pow(clampedNormalizedValue, power)
  
  // 4. Linearly interpolate between minTargetValue and maxTargetValue using the curved value
  let interpolatedValue = minTargetValue + curvedValue * (maxTargetValue - minTargetValue)
  
  // 5. Return the result (clamping is implicitly handled by the normalization/interpolation)
  //    but we can add explicit clamping for extra safety if needed.
  //    return max(minTargetValue, min(maxTargetValue, interpolatedValue)) // Optional extra clamping
  return interpolatedValue
}

/**
 Generates a random Int within the specified range, with an optional bias.
 
 This function adapts the biased float generation logic to map onto integer indices.
 
 - Parameters:
 - range: The closed range of integers within which to generate the random number.
 - bias: A value from -1.0 to +1.0 controlling the distribution bias (same as randCFloat). Defaults to 0.0.
 - biasStrengthBase: The base for the exponent calculation (same as randCFloat). Defaults to 3.0.
 - Returns: A biased random Int within the specified range. Returns the lower bound
 if range.lowerBound >= range.upperBound.
 */
func randInt(
  in range: ClosedRange<Int>,
  bias: CGFloat = 0.0,
  biasStrengthBase: CGFloat = 3.0
) -> Int {
  let low = range.lowerBound
  let high = range.upperBound
  
  // Handle invalid or single-value ranges
  guard low < high else {
    return low
  }
  
  // Calculate the number of possible integer values in the range
  let count = high - low + 1
  guard count > 0 else { // Should be covered by low < high, but for safety
    return low
  }
  
  // --- Generate biased float between 0.0 and 1.0 ---
  // (This logic is identical to the core of randCFloat)
  let clampedBias = max(-1.0, min(1.0, bias))
  let exponent: CGFloat
  if abs(clampedBias) < 1e-6 {
    exponent = 1.0
  } else {
    let base = max(1.1, biasStrengthBase)
    exponent = pow(base, -clampedBias)
  }
  let r = CGFloat.random(in: 0.0...1.0)
  let r_biased = pow(r, exponent)
  // --- End of biased float generation ---
  
  
  // Map the biased float [0.0, 1.0] to an integer index [0, count-1]
  // Multiply by count to scale, then use floor to get the integer index.
  // floor ensures that values like 0.99 map to index 0, 1.99 to index 1, etc.,
  // correctly reflecting the probability distribution of r_biased.
  let index_float = r_biased * CGFloat(count)
  let index = Int(floor(index_float))
  
  // Clamp index to be safe (r_biased could theoretically be exactly 1.0)
  let clamped_index = min(index, count - 1)
  
  // Calculate the final integer result
  let result = low + clamped_index
  
  return result
}

/**
 Generates a random CGFloat within the specified range, with an optional bias.
 
 - Parameters:
 - range: The closed range within which to generate the random number.
 - bias: A value from -1.0 to +1.0 controlling the distribution.
 - -1.0: Strong bias towards the lower end of the range.
 -  0.0: Uniform distribution (no bias).
 - +1.0: Strong bias towards the upper end of the range.
 Values outside [-1.0, 1.0] are clamped. Defaults to 0.0.
 - biasStrengthBase: The base for the exponent calculation, controlling how
 strong the bias effect is. Higher values mean stronger bias
 at the extremes (-1.0 or +1.0). Defaults to 3.0.
 - Returns: A biased random CGFloat within the specified range. Returns the lower bound
 if range.lowerBound == range.upperBound.
 */
func randCFloat(
  in range: ClosedRange<CGFloat>,
  bias: CGFloat = 0.0,
  biasStrengthBase: CGFloat = 3.0
) -> CGFloat {
  let low = range.lowerBound
  let high = range.upperBound
  
  // Handle case where range has zero width
  guard low < high else {
    return low
  }
  
  // 1. Clamp bias to the range [-1.0, 1.0]
  let clampedBias = max(-1.0, min(1.0, bias))
  
  // 2. Calculate the exponent based on the bias
  // exponent > 1 biases towards 0.0; exponent < 1 biases towards 1.0
  let exponent: CGFloat
  if abs(clampedBias) < 1e-6 { // Check if bias is effectively zero
    exponent = 1.0
  } else {
    // Ensure base is positive for pow
    let base = max(1.1, biasStrengthBase) // Use 1.1 minimum to ensure effect
    exponent = pow(base, -clampedBias)
  }
  
  // 3. Generate a uniform random number r in [0.0, 1.0]
  let r = CGFloat.random(in: 0.0...1.0)
  
  // 4. Apply the exponent to bias the distribution
  let r_biased = pow(r, exponent)
  
  // 5. Linearly map the biased r (still in [0.0, 1.0]) to the target range [low, high]
  let result = low + r_biased * (high - low)
  
  // Ensure result is strictly within the original range (due to potential float inaccuracies)
  return max(low, min(high, result))
}

/**
 Returns true with a probability corresponding to the given percentage.
 
 - Parameter pct: The percentage chance (0.0 to 100.0) for the function to return true.
 Values outside this range are clamped (<=0 returns false, >=100 returns true).
 - Returns: A Bool indicating whether the random chance succeeded.
 */
func chance(_ pct: Int) -> Bool {
  chance(Double(pct))
}
func chance(_ pct: Double) -> Bool {
  // Handle percentages outside the valid range
  if pct <= 0.0 {
    return false
  }
  if pct >= 100.0 {
    return true
  }
  
  // Generate a random Double between 0.0 (inclusive) and 100.0 (exclusive)
  let randomValue = Double.random(in: 0.0..<100.0)
  
  // Check if the random value falls below the desired percentage threshold
  return randomValue < pct
}

// --- Function to print error messages to stderr ---
func printError(_ message: String) {
  if let data = (message + "\n").data(using: .utf8) {
    FileHandle.standardError.write(data)
  } else {
    fputs(message + "\n", stderr)
  }
}

enum ImageUtils {
  /**
   Creates a new bitmap graphics context (canvas) in memory.
   
   - Parameters:
   - width: The desired width of the image in pixels.
   - height: The desired height of the image in pixels.
   - Returns: A `CGContext` instance ready for drawing, or `nil` if context creation fails.
   The caller is responsible for managing the context's lifecycle.
   Drawing operations can be performed directly on the returned context.
   */
  static func setupCanvas(width: Int, height: Int) -> CGContext? {
    // Ensure dimensions are valid
    guard width > 0 && height > 0 else {
      printError("[Error] Image dimensions must be positive.")
      return nil
    }
    
    let bitsPerComponent = 8 // 8 bits per color component (R, G, B, A) -> 0-255 range
    let bytesPerPixel = 4 // 4 components (RGBA) * 1 byte per component (since bitsPerComponent is 8)
    let bytesPerRow = width * bytesPerPixel
    let colorSpace = CGColorSpaceCreateDeviceRGB() // Use the standard device RGB color space
    
    // Define the bitmap format: RGBA with alpha component last, premultiplied.
    // kCGImageAlphaPremultipliedLast specifies that the color components are already
    // multiplied by the alpha value. This is a common format.
    let bitmapInfo = CGImageAlphaInfo.premultipliedLast.rawValue // Equivalent to CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
    
    // Create the bitmap context.
    // Passing `nil` for `data` tells Core Graphics to allocate and manage the memory buffer.
    let context = CGContext(data: nil,
                            width: width,
                            height: height,
                            bitsPerComponent: bitsPerComponent,
                            bytesPerRow: bytesPerRow,
                            space: colorSpace,
                            bitmapInfo: bitmapInfo)
    
    // (Context: Current time is Saturday, March 29, 2025 at 8:48 PM in Wichita Falls, Texas)
    if context == nil {
      printError("[Error] Failed to create CGContext.")
    }
    
    // Flip the coordinate system if needed (Optional but common for macOS/iOS)
    // Core Graphics default origin is bottom-left. AppKit/UIKit often expect top-left.
    // Flipping it here makes drawing coordinates more intuitive if you think top-left.
    // If you prefer bottom-left, you can remove these two lines.
    context?.translateBy(x: 0, y: CGFloat(height))
    context?.scaleBy(x: 1.0, y: -1.0)
    
    
    return context
  }
  
  /**
   Saves the contents of a CGContext as a PNG image file.
   
   - Parameters:
   - context: The `CGContext` containing the image data to save.
   - folderName: The name of the subfolder (within Desktop) to save the image into.
   - imageNum: The number for this specific image (used in the filename).
   - Returns: `true` if saving was successful, `false` otherwise.
   */
  static func saveImage(context: CGContext, imageNum: Int, commitHash: String?) -> Bool { // Removed folderName parameter
    // 1. Get a CGImage from the context
    guard let cgImage = context.makeImage() else {
      printError("[Error] Could not create CGImage from context.")
      return false
    }
    
    // 2. Determine the save location (Current Working Directory)
    let currentDirectoryPath = FileManager.default.currentDirectoryPath
    let baseDirectoryURL = URL(fileURLWithPath: currentDirectoryPath, isDirectory: true)
    
    // 3. Define the target subfolder name and create the URL
    let subfolderName = "../images"
    let folderURL = baseDirectoryURL.appendingPathComponent(subfolderName, isDirectory: true)
    
    // 4. Create the 'images' directory if it doesn't exist
    do {
      try FileManager.default.createDirectory(at: folderURL, withIntermediateDirectories: true, attributes: nil)
    } catch {
      printError("[Error] Could not create directory '\(folderURL.path)': \(error.localizedDescription)")
      return false
    }
    
    // 5. Generate the filename
    let filename = FileUtils.generateFilename(imageNum: imageNum, commitHash: commitHash) // Uses the top-level function
    let fileURL = folderURL.appendingPathComponent(filename)
    
    // 6. Create an image destination pointing to the file URL
    guard let destination = CGImageDestinationCreateWithURL(fileURL as CFURL, UTType.png.identifier as CFString, 1, nil) else {
      printError("[Error] Could not create image destination for URL: \(fileURL.path)")
      return false
    }
    
    // 7. Add the CGImage to the destination
    CGImageDestinationAddImage(destination, cgImage, nil)
    
    // 8. Finalize the destination (writes the data to the file)
    guard CGImageDestinationFinalize(destination) else {
      printError("[Error] Could not write PNG data to file: \(fileURL.path)")
      return false
    }
    
    print("Successfully saved image to relative path: \(subfolderName)/\(filename)") // More relevant message
    return true
  }

  // --- Other image utility functions will go here later ---
  // e.g., function to save context to PNG, function to draw shapes, etc.
  
}

enum FileUtils {
  static func generateFilename(prefix: String = "art", imageNum: Int, commitHash: String?, suffix: String = "png") -> String {
    let ch = commitHash ?? "NOHASH"
    let now = Date() // Get current date/time
    let formatter = DateFormatter()
    formatter.dateFormat = "yyyyMMdd_HHmmss" // Timestamp format
    let timestamp = formatter.string(from: now)
    let numString = String(format: "%05d", imageNum)
    return "\(prefix)_\(timestamp)_\(numString)_\(ch).\(suffix)"
  }
}

enum MathUtils {
  static func normalize(_ value: Double, min: Double, max: Double) -> Double {
    guard max != min else {
      // Handle the case where the range is zero to avoid division by zero.
      // Depending on context, you might return 0, 0.5, NaN, or throw an error.
      // Returning 0 is a simple choice if value is expected to equal min/max.
      return 0.0
    }
    return (value - min) / (max - min)
  }
  
  /**
   Converts an angle from degrees to radians.
   
   - Parameter deg: The angle in degrees.
   - Returns: The equivalent angle in radians.
   */
  static func degToRad(_ deg: CGFloat) -> CGFloat {
    return deg * .pi / 180.0
  }
  
  /**
   Converts an angle from radians to degrees.
   
   - Parameter rad: The angle in radians.
   - Returns: The equivalent angle in degrees.
   */
  static func radToDeg(_ rad: CGFloat) -> CGFloat {
    return rad * 180.0 / .pi
  }
}

// Structure to hold command line options
struct CommandOptions {
  var generatorName: String = "basic" // Default generator
  var numImagesToGenerate: Int = 15    // Default number of images
  var commitHash: String = ""
}

// Enum to act as a namespace for command-line related utilities
enum CommandLineUtils {
  
  // Define specific errors for parsing failures
  enum ParsingError: Error, LocalizedError {
    case tooManyArguments
    case invalidImageCount(String)
    case nonPositiveImageCount(Int)
    case unknownGenerator(String)
    
    // Provide user-friendly descriptions for errors
    var errorDescription: String? {
      switch self {
        case .tooManyArguments:
          // Updated message as hash is now expected from script
          return "[Error] Incorrect number of arguments provided by script."
        case .invalidImageCount(let value):
          return "[Error] Invalid image count provided ('\(value)'). Please enter a number."
        case .nonPositiveImageCount(let number):
          // Corrected error message to reflect the invalid number
          return "[Error] Image count ('\(number)') must be a positive integer (>= 1)."
        case .unknownGenerator(let name):
          return "[Error] Unknown generator type: '\(name)'"
      }
    }
  }
  
  // --- Function to print usage instructions ---
  // Note: Doesn't explicitly mention the commit hash, as it's passed by the script.
  static func printUsage(executableName: String, availableGenerators: Set<String>) {
    let usage = """
        Usage (when run manually): \(executableName) [generator_name] [num_images]
        
        Arguments:
          generator_name  Optional: The type of generator to use (default: \(CommandOptions().generatorName)).
                          Available: \(availableGenerators.sorted().joined(separator: ", "))
          num_images      Optional: The number of images to generate (default: \(CommandOptions().numImagesToGenerate)). Must be >= 1.
        
        Note: When run via the recommended script, a commit hash is also passed automatically.
        """
    printError(usage) // Print usage to standard error
  }
  
  // --- Function to parse arguments ---
  // Updated to handle the commit hash as the 4th argument (index 3)
  static func parseArguments(_ args: [String], availableGenerators: Set<String>) -> Result<CommandOptions, ParsingError> {
    var options = CommandOptions()
    let argCount = args.count
    
    // args[0] is the executable path
    // args[1] is generator_name (optional)
    // args[2] is num_images (optional)
    // args[3] is commit_hash (passed by script)
    
    // Check for valid number of arguments (1 to 4)
    guard argCount <= 4 else {
      // If more than 4 args, it's unexpected
      return .failure(.tooManyArguments)
    }
    
    // Parse generator name (if provided at index 1)
    if argCount >= 2 {
      options.generatorName = args[1]
    }
    
    // Parse number of images (if provided at index 2)
    if argCount >= 3 {
      let countString = args[2]
      guard let number = Int(countString) else {
        return .failure(.invalidImageCount(countString))
      }
      guard number > 0 else {
        // Pass the invalid number to the error
        return .failure(.nonPositiveImageCount(number))
      }
      options.numImagesToGenerate = number
    }
    
    // Parse commit hash (if provided at index 3)
    if argCount == 4 {
      // Assign the hash, even if empty (filename generation handles empty)
      options.commitHash = args[3]
    }
    // If argCount is less than 4, options.commitHash remains nil (its default)
    
    // --- Validate Generator Name ---
    // Ensure the selected generator (default or from args) is valid
    guard availableGenerators.contains(options.generatorName) else {
      return .failure(.unknownGenerator(options.generatorName))
    }
    
    // If all checks pass, return the populated options
    return .success(options)
  }
}

/**
 Calculates a biased random offset range to push away from boundaries.
 
 The function adjusts the standard offset range `(-maxAbsOffset...maxAbsOffset)`
 based on the current value's proximity to the `minV` and `maxV` boundaries.
 The closer the value is to a boundary, the more the offset range towards
 that boundary is reduced. The reduction follows a power curve for a stronger
 effect near the boundaries.
 
 - Parameters:
 - v: The current value on the axis (e.g., x or y coordinate).
 - minV: The minimum boundary value for the axis.
 - maxV: The maximum boundary value for the axis.
 - maxAbsOffset: The maximum absolute offset allowed when far from boundaries (e.g., 10).
 - influenceRatio: The fraction of the total range near each boundary where the biasing effect is active (e.g., 0.25 means the effect happens within 25% of the edge). Defaults to 0.25.
 - power: The exponent used for non-linear scaling. Higher values (>1) increase the biasing effect closer to the walls. Defaults to 2.0 (quadratic).
 - Returns: A `ClosedRange<Int>` representing the biased offset range.
 */
func getBiasedOffsetRange(
  v: CGFloat,
  minV: CGFloat,
  maxV: CGFloat,
  maxAbsOffset: Int,
  influenceRatio: CGFloat = 0.25,
  power: CGFloat = 2.0
) -> ClosedRange<Int> {
  
  // --- Input Validation ---
  guard maxV > minV else {
    printError("[getBiasedOffsetRange] maxV (\(maxV)) must be greater than minV (\(minV)).")
    return 0...0 // Invalid range
  }
  guard influenceRatio > 0 && influenceRatio <= 1.0 else {
    printError("[getBiasedOffsetRange] influenceRatio must be between 0 (exclusive) and 1 (inclusive). Using default 0.25.")
    // Recurse with default ratio
    return getBiasedOffsetRange(v: v, minV: minV, maxV: maxV, maxAbsOffset: maxAbsOffset, influenceRatio: 0.25, power: power)
  }
  guard power > 0 else {
    printError("[getBiasedOffsetRange] power must be positive. Using default 2.0.")
    // Recurse with default power
    return getBiasedOffsetRange(v: v, minV: minV, maxV: maxV, maxAbsOffset: maxAbsOffset, influenceRatio: influenceRatio, power: 2.0)
  }
  
  // --- Calculations ---
  let totalRange = maxV - minV
  let floatOffset = CGFloat(maxAbsOffset)
  let influenceDistance = totalRange * influenceRatio
  
  // Ensure influence distance is positive to avoid division by zero if totalRange is tiny
  guard influenceDistance > 1e-6 else { // Use a small epsilon
    // If influence distance is effectively zero, no biasing can occur
    return -maxAbsOffset...maxAbsOffset
  }
  
  // --- Calculate scaling factor for the NEGATIVE offset ---
  // Based on distance to the minimum boundary (minV)
  let distToMin = v - minV
  // Normalize distance within the influence zone (0.0 at wall, 1.0 outside zone)
  // Clamp normalized distance to prevent issues if v is slightly outside [minV, maxV]
  let normDistMin = max(0.0, min(1.0, distToMin / influenceDistance))
  // Apply power curve and scale the negative offset magnitude
  let scaleNeg = pow(normDistMin, power)
  let minRange = -floatOffset * scaleNeg
  
  // --- Calculate scaling factor for the POSITIVE offset ---
  // Based on distance to the maximum boundary (maxV)
  let distToMax = maxV - v
  // Normalize distance within the influence zone
  let normDistMax = max(0.0, min(1.0, distToMax / influenceDistance))
  // Apply power curve and scale the positive offset magnitude
  let scalePos = pow(normDistMax, power)
  let maxRange = floatOffset * scalePos
  
  // --- Convert to Int range ---
  // Round the float limits to get integer bounds
  let finalMin = Int(round(minRange))
  let finalMax = Int(round(maxRange))
  
  // Ensure min is not greater than max (can happen with rounding near center)
  if finalMin > finalMax {
    // If they cross, return a small range around 0, or just 0...0
    // This can happen if maxAbsOffset is small and v is near the center.
    return 0...0
  }
  
  return finalMin...finalMax
}

import Foundation // For max/min
import CoreGraphics // For CGFloat

/**
 Calculates the next position for a value wandering within boundaries,
 applying a biased random offset to push away from the boundaries.
 
 This function uses `getBiasedOffsetRange` to determine the appropriate
 random step size based on proximity to `minV` and `maxV`.
 
 - Parameters:
 - prevV: The previous value on the axis (e.g., previous x or y).
 - minV: The minimum boundary value for the axis.
 - maxV: The maximum boundary value for the axis.
 - maxAbsOffset: The maximum absolute offset allowed when far from boundaries.
 - influenceRatio: The fraction of the total range near each boundary where the biasing effect is active. Defaults to 0.25.
 - power: The exponent used for non-linear scaling of the bias. Defaults to 2.0.
 - Returns: A `CGFloat` representing the calculated next value, clamped within [minV, maxV].
 */
func nextPointV(
  prevV: CGFloat,
  minV: CGFloat,
  maxV: CGFloat,
  maxAbsOffset: Int,
  influenceRatio: CGFloat = 0.25,
  power: CGFloat = 2.0
) -> CGFloat {
  
  // 1. Get the biased offset range using the helper function
  let offsetRange = getBiasedOffsetRange(
    v: prevV,
    minV: minV,
    maxV: maxV,
    maxAbsOffset: maxAbsOffset,
    influenceRatio: influenceRatio,
    power: power
  )
  
  // 2. Generate a random offset within the calculated range
  // Handle the case where the range might be empty (e.g., 0...-1)
  let offset: Int
  if offsetRange.isEmpty {
    offset = 0 // Default to no offset if the range is invalid
  } else {
    offset = Int.random(in: offsetRange)
  }
  
  // 3. Calculate the potential next value
  let nextV = prevV + CGFloat(offset)
  
  // 4. Clamp the result to ensure it stays within the defined boundaries
  let clampedNextV = max(minV, min(maxV, nextV))
  
  return clampedNextV
}

// --- Example Usage (Updated from previous example) ---

func wanderingPointExampleWithNextV(canvasWidth: Int, canvasHeight: Int, steps: Int) {
  // Define boundaries
  let minX: CGFloat = 0.0
  let maxX = CGFloat(canvasWidth)
  let minY: CGFloat = 0.0
  let maxY = CGFloat(canvasHeight)
  
  // Initial position
  var currentX = CGFloat.random(in: minX...maxX)
  var currentY = CGFloat.random(in: minY...maxY)
  
  // Parameters for biasing (passed to nextPointV)
  let maxOffset = 10 // The base maximum step size
  let boundaryInfluence: CGFloat = 0.2 // Effect active within 20% of edges
  let biasPower: CGFloat = 3.0 // Cubic bias - stronger effect near walls
  
  print("Starting at (\(currentX), \(currentY))")
  
  for i in 1...steps {
    // Calculate next X using the new function
    currentX = nextPointV(
      prevV: currentX,
      minV: minX,
      maxV: maxX,
      maxAbsOffset: maxOffset,
      influenceRatio: boundaryInfluence,
      power: biasPower
    )
    
    // Calculate next Y using the new function
    currentY = nextPointV(
      prevV: currentY,
      minV: minY,
      maxV: maxY,
      maxAbsOffset: maxOffset,
      influenceRatio: boundaryInfluence,
      power: biasPower
    )
    
    // In a real scenario, you would draw something at (currentX, currentY) here
    if i % 100 == 0 { // Print occasionally
      print("Step \(i): Pos=(\(String(format: "%.1f", currentX)), \(String(format: "%.1f", currentY)))")
    }
  }
  print("Finished at (\(currentX), \(currentY))")
}

// Example call (replace with your actual drawing loop)
// wanderingPointExampleWithNextV(canvasWidth: 2000, canvasHeight: 2000, steps: 5000)



**** draw.swift ****************************************************************
//
//  draw.swift
//  genimg
//
//  Created by Michael Teter on 2025-03-30.
//

import CoreGraphics

/**
 Defines how rotation should be applied.
 Includes options for fixed rotation, random rotation within a range (with optional offsets), or no rotation.
 */
enum RotationSpecification {
  /// Specify a fixed angle directly in DEGREES.
  case fixed(degrees: CGFloat)
  /// Specify a range in DEGREES for random selection, with optional additional offsets.
  case randomDegrees(range: ClosedRange<CGFloat>, offsetDeg: CGFloat? = nil, offsetRad: CGFloat? = nil)
  /// Explicitly no rotation.
  case none
}

// MARK: - Angle Calculation Function (Updated)

/**
 Calculates the final rotation angle in radians based on the RotationSpecification.
 
 - Parameter rotSpec: The `RotationSpecification` case defining the rotation rules.
 - Returns: The calculated angle in radians.
 */
func rotAngle(_ rotSpec: RotationSpecification) -> CGFloat {
  let angleInRadians: CGFloat
  
  switch rotSpec {
    case .fixed(let degrees):
      // Convert fixed degrees to radians
      angleInRadians = MathUtils.degToRad(degrees) // Use utility function [cite: degree_radian_conversion]
      
    case .randomDegrees(let degreeRange, let offsetDeg, let offsetRad):
      // 1. Get the base random angle in degrees
      let randomDegrees = CGFloat.random(in: degreeRange)
      // Convert base random degrees to radians
      var calculatedRadians = MathUtils.degToRad(randomDegrees) // Use utility function [cite: degree_radian_conversion]
      
      // 2. Calculate total offset in radians
      var totalOffsetRadians: CGFloat = 0.0
      if let degOffset = offsetDeg {
        totalOffsetRadians += MathUtils.degToRad(degOffset) // Convert degree offset
      }
      if let radOffset = offsetRad {
        totalOffsetRadians += radOffset // Add radian offset directly
      }
      
      // 3. Add the total offset to the base random angle
      calculatedRadians += totalOffsetRadians
      angleInRadians = calculatedRadians
      
    case .none:
      angleInRadians = 0.0
  }
  
  return angleInRadians
}

/**
 Draws a rectangle rotated around a specified or calculated center point,
 with optional fill and stroke, and flexible rotation options.
 
 - Parameters:
 - gc: The graphics context to draw into.
 - rect: The CGRect defining the rectangle's initial position (origin) and size.
 - center: Optional CGPoint to rotate around. If nil, rotates around the rect's natural center.
 - rotation: A `RotationSpecification` enum case defining how to rotate (uses DEGREES).
 - solid: If true, the rectangle will attempt to be filled using `fillColor`. Defaults to false.
 - strokeColor: Optional CGColor for the outline. If nil, no outline is drawn.
 - lineWidth: Optional CGFloat for the outline thickness. Only used if `strokeColor` is not nil.
 - fillColor: Optional CGColor for the interior. Only used if `solid` is true.
 */
func drawRotatedRect(gc: CGContext,
                     rect: CGRect, center: CGPoint? = nil, // Make center optional
                     rotation: RotationSpecification,
                     lineWidth: CGFloat? = nil, strokeColor: CGColor? = nil,
                     solid: Bool = false, fillColor: CGColor? = nil) {
  
  // 1. Determine the point to rotate around
  let rotationCenter: CGPoint
  if let explicitCenter = center {
    // Use the explicitly provided center point
    rotationCenter = explicitCenter
  } else {
    // Calculate the natural geometric center of the input rect
    rotationCenter = CGPoint(x: rect.midX, y: rect.midY)
  }
  
  // 2. Determine the angle in RADIANS
  // Assumes rotAngle function exists as defined previously
  let angleInRadians = rotAngle(rotation)
  
  // --- Save state, apply transforms, draw, restore state ---
  gc.saveGState()
  
  // 3. Apply Transformations centered around the rotation point
  gc.translateBy(x: rotationCenter.x, y: rotationCenter.y)
  gc.rotate(by: angleInRadians)
  
  // 4. Define the drawing geometry centered around the NEW (0,0) origin
  //    The size comes from the input rect.
  let drawingRect = CGRect(x: -rect.size.width / 2.0,
                           y: -rect.size.height / 2.0,
                           width: rect.size.width,
                           height: rect.size.height)
  
  // 5. Delegate the actual drawing to drawRect (or integrate its logic)
  //    This draws the centered rectangle within the transformed coordinate space
  //    Assumes drawRect function exists as defined previously
  drawRect(gc: gc, rect: drawingRect,
           lineWidth: lineWidth, strokeColor: strokeColor,
           solid: solid, fillColor: fillColor)
  
  // 6. Restore State
  gc.restoreGState()
}

func centeredRect(for size: CGSize) -> CGRect {
  // This is to be used on a translated gc
  return CGRect(x: -size.width / 2.0,
                y: -size.height / 2.0,
                width: size.width,
                height: size.height)
}

func drawRect(gc: CGContext,
              rect: CGRect,
              lineWidth: CGFloat? = nil, strokeColor: CGColor? = nil,
              solid: Bool = false, fillColor: CGColor? = nil) {
  // This assumes a translated gc and a rect whose center is (0,0)
  if solid, let fillC = fillColor {
    gc.setFillColor(fillC)
    gc.fill(rect)
  }
  
  if let strokeC = strokeColor {
    if let lw = lineWidth {
      gc.setLineWidth(lw)
    }
    gc.setStrokeColor(strokeC)
    gc.stroke(rect)
  }
}

/**
 Fills the entire graphics context with a solid color.
 
 - Parameters:
 - gc: The graphics context to fill.
 - color: The optional CGColor to fill with. If nil, defaults to black.
 */
func solidBackground(gc: CGContext, color: CGColor? = nil) {
  // 1. Determine the color: Use the provided color, or default to black if nil.
  //    CGColor(gray: 0.0, alpha: 1.0) creates black.
  let actualColor = color ?? CGColor(gray: 0.0, alpha: 1.0)
  
  // 2. Set the fill color on the graphics context
  gc.setFillColor(actualColor)
  
  // 3. Define the rectangle covering the entire context area
  //    Using the context's width and height properties.
  let rect = CGRect(x: 0, y: 0, width: gc.width, height: gc.height)
  
  // 4. Fill the entire rectangle
  gc.fill(rect)
}

/**
 Draws a circle with a specified center and radius, with optional fill and stroke.
 
 - Parameters:
 - gc: The graphics context to draw into.
 - center: The CGPoint defining the circle's center.
 - radius: The CGFloat defining the circle's radius. Must be positive.
 - lineWidth: Optional CGFloat for the outline thickness. Only used if `strokeColor` is not nil. Defaults to 1.0 if `strokeColor` is set but `lineWidth` is nil.
 - strokeColor: Optional CGColor for the outline. If nil, no outline is drawn.
 - solid: If true, the circle will be filled using `fillColor`. Defaults to false.
 - fillColor: Optional CGColor for the interior. Only used if `solid` is true. Defaults to black if `solid` is true but `fillColor` is nil.
 */
func drawCircle(gc: CGContext,
                center: CGPoint,
                radius: CGFloat,
                lineWidth: CGFloat? = nil, // Default handled below if stroke applied
                strokeColor: CGColor? = nil,
                solid: Bool = false,
                fillColor: CGColor? = nil) // Default handled below if solid applied
{
  // Ensure radius is valid
  guard radius > 0 else {
    printError("[drawCircle] Radius must be positive.")
    return
  }
  
  // --- Save state, define path, draw, restore state ---
  gc.saveGState()
  
  // 1. Define the bounding rectangle for the circle
  // Origin is (center.x - radius, center.y - radius)
  // Size is (radius * 2, radius * 2)
  let diameter = radius * 2.0
  let rect = CGRect(x: center.x - radius, y: center.y - radius, width: diameter, height: diameter)
  
  // 2. Create the ellipse path
  // For a circle, addEllipse is perfect.
  // Alternatively, create a CGMutablePath, add the ellipse, then gc.addPath(path).
  gc.addEllipse(in: rect)
  
  // 3. Determine drawing mode and set colors/line width
  var drawMode: CGPathDrawingMode? = nil
  
  if solid {
    // Use provided fill color, or default to black if solid is true but no color given
    let actualFillColor = fillColor ?? CGColor(gray: 0.0, alpha: 1.0) // Black default
    gc.setFillColor(actualFillColor)
    drawMode = .fill // Start with fill mode
  }
  
  if let strokeC = strokeColor {
    gc.setStrokeColor(strokeC)
    // Use provided line width, or default to 1.0 if stroke applied but no width given
    gc.setLineWidth(lineWidth ?? 1.0) // Default line width 1.0
    
    // Update draw mode: if already filling, change to fillStroke, otherwise set to stroke
    if drawMode == .fill {
      drawMode = .fillStroke
    } else {
      drawMode = .stroke
    }
  }
  
  // 4. Draw the path if a mode was determined
  if let mode = drawMode {
    gc.drawPath(using: mode)
  } else {
    // If neither solid nor strokeColor was set, the path added above is simply discarded.
    // Alternatively, clear the path: gc.beginPath(); gc.closePath() if needed,
    // but save/restore GState handles this cleanly.
    // print("[drawCircle] Warning: Neither fill nor stroke specified.") // Optional warning
  }
  
  
  // 5. Restore State
  gc.restoreGState()
}


**** main.swift ****************************************************************
//
//  main.swift
//  genimg
//
//  Created by Michael Teter on 2025-03-29.
//  Updated 2025-03-31 to handle commit hash argument.
//

import Foundation // Needed for exit(), FileHandle, String encoding
import CoreGraphics // Needed for CGColor, CGRect if adding drawing later

// --- Define available generators ---
// This might come from elsewhere eventually, but keep it here for now
// TODO: Consider populating this dynamically if generators become pluggable
let availableGenerators: Set<String> = ["basic", "circles", "lines", "noise", "colorTest", "rectLanes", "demoPalettes", "wander", "impcirdemo"] // Added generators from image_generators.swift

// --- Image Generation Logic ---
// Updated signature to accept commitHash
func runImageGeneration(generatorName: String, nImages: Int, commitHash: String?) {
  let ch = commitHash ?? "(none)"
  print("Generating \(nImages) image(s) using generator '\(generatorName)' with code hash '\(ch)'...")
  if let hash = commitHash {
    print("Code version (commit hash): \(hash)")
  } else {
    print("[Warning] No commit hash provided.")
  }
  
  // Define desired image dimensions
  let canvasWidth = 2000
  let canvasHeight = 2000
  
  // Loop to generate the requested number of images
  for i in 1...nImages {
    print("Starting image \(i) of \(nImages)...")
    // Calls the static function in ImageUtils from Utils.swift
    guard let gc = ImageUtils.setupCanvas(width: canvasWidth, height: canvasHeight) else {
      printError("[Error] Failed to setup canvas for image \(i). Skipping.")
      continue // Skip to the next image in the loop
    }
    
    // --- Select and Run Generator Function ---
    // Use a dictionary to map names to functions for cleaner dispatch
    let generatorMap: [String: (CGContext) -> Void] = [
      "basic": do_basic, // Assumes do_basic exists (from image_generators.swift)
      "basic_rot": do_basic_rot, // Assumes do_basic_rot exists
      "colorTest": colorTest, // Assumes colorTest exists
      "rectLanes": rectLanes, // Assumes rectLanes exists
      "demoPalettes": demoPalettes,
      "wander": wander,
      "impcirdemo": impCirDemo,
      // Add other generators here as they are created
      "circles": { gc in printError("[Error] 'circles' generator not yet implemented.") },
      "lines": { gc in printError("[Error] 'lines' generator not yet implemented.") },
      "noise": { gc in printError("[Error] 'noise' generator not yet implemented.") }
    ]
    
    if let generatorFunc = generatorMap[generatorName] {
      print("Running generator '\(generatorName)'...")
      generatorFunc(gc) // Execute the selected generator function
      print("Generator '\(generatorName)' finished.")
    } else {
      // This case should ideally be caught by argument parsing, but good to have a fallback
      printError("[Error] Unknown generator name '\(generatorName)' provided to runImageGeneration.")
      // Optionally draw a placeholder or leave canvas blank
      solidBackground(gc: gc, color: makeColor(r: 50, g: 0, b: 0)) // Dark red background for error
    }
    
    // --- Save Image ---
    // Updated call to include commitHash
    if !ImageUtils.saveImage(context: gc, imageNum: i, commitHash: commitHash) {
      printError("[Error] Failed to save image \(i).")
    } else {
      // Success message is now printed within saveImage
    }
    print("Finished processing image \(i).")
    
  } // end for i nImages
  print("Image generation loop complete.")
}

// --- Main Execution Logic ---

func main() {
  // Get command line arguments and executable name
  let args = CommandLine.arguments
  // Use a more robust way to get executable name if needed, this is basic
  let executableName = URL(fileURLWithPath: args[0]).lastPathComponent
  
  print("Starting \(executableName)...")
  
  // Parse arguments using the utility function
  // Assumes parseArguments and printUsage are updated in CommandLineUtils (util.swift)
  // to handle the commit hash argument.
  let parseResult = CommandLineUtils.parseArguments(args, availableGenerators: availableGenerators)
  
  // Handle the result of parsing
  switch parseResult {
    case .success(let options):
      print("Arguments parsed successfully.")
      // --- Dispatch to Generator ---
      // Pass the parsed options, including the commitHash, to the generation function
      runImageGeneration(
        generatorName: options.generatorName,
        nImages: options.numImagesToGenerate,
        commitHash: options.commitHash // Pass the hash
      )
      print("\(executableName) finished successfully.")
      // Implicit exit code 0
      
    case .failure(let error):
      // Call the top-level printError function directly with the description
      printError(error.localizedDescription)
      
      // Print usage instructions
      CommandLineUtils.printUsage(executableName: executableName, availableGenerators: availableGenerators)
      exit(1) // Exit with error code
  }
}

// --- Program Entry Point ---
main()


**** color.swift ***************************************************************
// Color.swift

import CoreGraphics
import Foundation // Needed for Scanner
import AppKit

func makeColor(r: Int, g: Int, b: Int, a: CGFloat = 1.0) -> CGColor {
  let red = CGFloat(max(0, min(255, r))) / 255.0
  let green = CGFloat(max(0, min(255, g))) / 255.0
  let blue = CGFloat(max(0, min(255, b))) / 255.0
  return CGColor(srgbRed: red, green: green, blue: blue, alpha: a)
}

// --- Hex to CGColor Conversion ---
/**
 Creates a CGColor from a hex string (e.g., "FF0000", "#FF0000").
 Returns nil if the hex string is invalid.
 */
func colorFromHex(_ hexString: String) -> CGColor? {
  var hexSanitized = hexString.trimmingCharacters(in: .whitespacesAndNewlines)
  hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
  
  guard hexSanitized.count == 6 else {
    return nil // Invalid length
  }
  
  var rgbValue: UInt64 = 0
  guard Scanner(string: hexSanitized).scanHexInt64(&rgbValue) else {
    return nil // Failed to scan hex value
  }
  
  let r = Int((rgbValue & 0xFF0000) >> 16)
  let g = Int((rgbValue & 0x00FF00) >> 8)
  let b = Int(rgbValue & 0x0000FF)
  
  return makeColor(r: r, g: g, b: b)
}

/**
 Adjusts the lightness/brightness of a color based on perception using the HSB color space.
 
 - Parameters:
 - color: The input CGColor.
 - percentage: The amount to adjust brightness by. Ranges from -1.0 (black) to 1.0 (white).
 A positive value makes the color lighter.
 A negative value makes the color darker.
 A value of 0.0 returns the original color.
 - Returns: An optional CGColor (`CGColor?`) with adjusted brightness, or nil if conversion fails.
 */
func adjustLightness(of color: CGColor, by percentage: CGFloat) -> CGColor? {
  
  // 1. Convert CGColor to NSColor
  // NSColor initializers can handle various CGColor spaces, attempting conversion.
  guard let nsColor = NSColor(cgColor: color) else {
    printError("[adjustLightness] Failed to convert CGColor to NSColor.")
    return nil // Return nil if initial conversion fails
  }
  
  // 2. Get HSB components from NSColor
  // We need variables to store the components.
  var hue: CGFloat = 0.0
  var saturation: CGFloat = 0.0
  var brightness: CGFloat = 0.0
  var alpha: CGFloat = 0.0
  
  // Attempt to get components in HSB space. This might fail if the color
  // cannot be represented in HSB (e.g., pure white/black/gray might sometimes
  // require special handling or have hue/saturation undefined, but NSColor often handles this).
  // We need to ensure the NSColor is in an RGB-compatible space first for reliable HSB conversion.
  guard let rgbColor = nsColor.usingColorSpace(.sRGB) else {
    printError("[adjustLightness] Failed to convert NSColor to sRGB before getting HSB.")
    return nil
  }
  
  rgbColor.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: &alpha)
  
  // 3. Calculate the new brightness
  var newBrightness = brightness
  
  // Clamp percentage between -1.0 and 1.0
  let clampedPercentage = max(-1.0, min(1.0, percentage))
  
  if clampedPercentage > 0 {
    // Increase brightness: Adjust towards white (1.0)
    newBrightness += (1.0 - brightness) * clampedPercentage
  } else {
    // Decrease brightness: Adjust towards black (0.0)
    newBrightness += brightness * clampedPercentage // percentage is negative here
  }
  
  // Ensure newBrightness stays within the valid range [0.0, 1.0]
  newBrightness = max(0.0, min(1.0, newBrightness))
  
  // 4. Create new NSColor with adjusted brightness
  let newNSColor = NSColor(hue: hue,
                           saturation: saturation,
                           brightness: newBrightness,
                           alpha: alpha)
  
  // 5. Convert back to CGColor
  // We request it back in the sRGB space for consistency.
  guard let newCGColor = newNSColor.usingColorSpace(.sRGB)?.cgColor else {
    printError("[adjustLightness] Failed to convert final NSColor back to CGColor.")
    return nil
  }
  
  return newCGColor
}

/**
 Mixes a given color with its equivalent gray value based on luminance.
 
 - Parameters:
 - color: The input CGColor.
 - strength: The amount of gray to mix in, ranging from 0.0 (original color)
 to 1.0 (fully gray). Values outside this range are clamped.
 - Returns: An optional CGColor (`CGColor?`) representing the mixed color,
 or nil if the input color could not be processed (e.g., invalid color space).
 */
func grayTone(_ color: CGColor, strength: CGFloat) -> CGColor? {
  
  // 1. Clamp strength to the valid range [0.0, 1.0]
  let mixFactor = max(0.0, min(1.0, strength))
  
  // If strength is 0, return the original color directly
  if mixFactor == 0.0 {
    return color
  }
  
  // 2. Convert input color to a standard RGB space (sRGB) for component access
  guard let srgbColorSpace = CGColorSpace(name: CGColorSpace.sRGB),
        let rgbColor = color.converted(to: srgbColorSpace, intent: .defaultIntent, options: nil)
  else {
    printError("[grayTone] Failed to convert input color to sRGB.")
    return nil
  }
  
  // 3. Get RGB components and alpha
  guard let components = rgbColor.components, components.count >= 3 else {
    printError("[grayTone] Failed to get RGB components from the color.")
    return nil // Should not happen after successful conversion, but good practice
  }
  
  let r = components[0]
  let g = components[1]
  let b = components[2]
  let alpha = rgbColor.alpha // Preserve original alpha
  
  // 4. Calculate the luminance (perceived brightness) for the gray value
  // Using Rec. 709 coefficients (common standard)
  let grayValue = 0.2126 * r + 0.7152 * g + 0.0722 * b
  
  // If strength is 1.0, return the calculated gray directly
  if mixFactor == 1.0 {
    return CGColor(srgbRed: grayValue, green: grayValue, blue: grayValue, alpha: alpha)
  }
  
  // 5. Linearly interpolate between original color and gray value
  let invMixFactor = 1.0 - mixFactor
  let newR = (r * invMixFactor) + (grayValue * mixFactor)
  let newG = (g * invMixFactor) + (grayValue * mixFactor)
  let newB = (b * invMixFactor) + (grayValue * mixFactor)
  
  // 6. Create and return the new mixed color
  return CGColor(srgbRed: newR, green: newG, blue: newB, alpha: alpha)
}

// --- Complementary Color Function ---
/**
 Calculates the simple complementary color (opposite on RGB color wheel).
 Assumes the input color is in an RGB-like color space.
 Returns black if component extraction fails.
 */
func complement(_ color: CGColor) -> CGColor {
  // Try to get RGB components (works directly for sRGB or deviceRGB)
  guard let components = color.components, components.count >= 3 else {
    // Could try converting color space first, but return black for simplicity
    return makeColor(r: 0, g: 0, b: 0)
  }
  
  // Components are typically 0.0-1.0 CGFloat
  let r = components[0]
  let g = components[1]
  let b = components[2]
  let a = color.alpha // Preserve alpha
  
  // Simple complement calculation
  let compR = 1.0 - r
  let compG = 1.0 - g
  let compB = 1.0 - b
  
  // Create the new color using the same alpha
  // Assuming sRGB is appropriate for the complement
  return CGColor(srgbRed: compR, green: compG, blue: compB, alpha: a)
}

enum Palettes {
  // Saint Catherine Palette
  static let saintCath: [CGColor] = [
    makeColor(r: 252, g: 229, b: 189), // light beige / pale peach
    makeColor(r: 107, g: 81, b: 46),   // dark brown / coffee
    makeColor(r: 191, g: 51, b: 34),   // strong red / brick red
    makeColor(r: 101, g: 101, b: 129), // desaturated slate blue / grayish blue
    makeColor(r: 230, g: 164, b: 90)   // orange-tan / light ochre
  ]
  
  // Girl with a Pearl Earring Palette
  static let girlPearl: [CGColor] = [
    makeColor(r: 18, g: 11, b: 19),    // very dark purple / near black
    makeColor(r: 72, g: 93, b: 165),   // moderate blue / slate blue
    makeColor(r: 205, g: 182, b: 122), // light tan / pale gold
    makeColor(r: 137, g: 97, b: 53),   // medium brown / tan
    makeColor(r: 112, g: 40, b: 33)    // dark reddish-brown / mahogany
  ]
  
  // Hokusai Palette
  static let hokusai: [CGColor] = [
    makeColor(r: 125, g: 155, b: 166), // dusty blue / grayish cyan
    makeColor(r: 192, g: 183, b: 168), // light grayish tan / beige
    makeColor(r: 221, g: 211, b: 196), // very pale beige / off-white
    makeColor(r: 16, g: 40, b: 74),    // dark navy blue
    makeColor(r: 71, g: 75, b: 78)     // dark gray / charcoal
  ]
  
  // L'Étoile Palette
  static let letoile: [CGColor] = [
    makeColor(r: 122, g: 101, b: 78),  // grayish brown / taupe
    makeColor(r: 233, g: 203, b: 183), // pale pinkish beige
    makeColor(r: 172, g: 113, b: 59),  // medium brown / light sienna
    makeColor(r: 120, g: 129, b: 141), // cool gray / slate gray
    makeColor(r: 53, g: 46, b: 35)     // very dark brown / espresso
  ]
  
  // Mona Lisa Palette
  static let mona: [CGColor] = [
    makeColor(r: 2, g: 9, b: 15),      // very dark blue / near black
    makeColor(r: 240, g: 198, b: 112), // light orange-yellow / pale ochre
    makeColor(r: 47, g: 49, b: 29),    // dark olive green
    makeColor(r: 93, g: 114, b: 69),   // medium olive green / moss green
    makeColor(r: 91, g: 61, b: 38)     // medium dark brown
  ]
  
  // Nighthawks Palette
  static let nighthawks: [CGColor] = [
    makeColor(r: 119, g: 52, b: 30),   // reddish brown / dark sienna
    makeColor(r: 235, g: 227, b: 135), // pale yellow / light greenish-yellow
    makeColor(r: 98, g: 142, b: 113),  // dusty green / grayish-green
    makeColor(r: 21, g: 43, b: 54),    // very dark desaturated cyan / dark teal blue
    makeColor(r: 33, g: 40, b: 37)     // very dark green / near black
  ]
  
  // Starry Night Palette
  static let starry: [CGColor] = [
    makeColor(r: 7, g: 12, b: 15),     // very dark blue / near black
    makeColor(r: 29, g: 88, b: 128),   // strong blue / medium dark blue
    makeColor(r: 254, g: 206, b: 62),  // bright yellow / gold
    makeColor(r: 248, g: 226, b: 136), // light yellow / pale yellow
    makeColor(r: 159, g: 199, b: 152)  // light green / pale mint green
  ]
  
  // The Kiss Palette
  static let kiss: [CGColor] = [
    makeColor(r: 125, g: 106, b: 60), // dark gold / olive brown
    makeColor(r: 199, g: 169, b: 77), // medium gold / ochre
    makeColor(r: 119, g: 143, b: 80), // olive green / moss green
    makeColor(r: 142, g: 117, b: 128),// dusty mauve / desaturated purple-pink
    makeColor(r: 182, g: 100, b: 78)  // brownish orange / terracotta
  ]
  
  // The Night Watch Palette
  static let nightwatch: [CGColor] = [
    makeColor(r: 11, g: 13, b: 12),    // very dark gray / near black
    makeColor(r: 245, g: 220, b: 150), // pale yellow / light beige
    makeColor(r: 129, g: 38, b: 15),   // dark red / reddish brown
    makeColor(r: 36, g: 28, b: 15),    // very dark brown
    makeColor(r: 42, g: 44, b: 40)     // dark grayish green
  ]
  
  // The Scream Palette
  static let scream: [CGColor] = [
    makeColor(r: 208, g: 64, b: 11),   // strong orange-red
    makeColor(r: 30, g: 53, b: 57),    // very dark desaturated cyan / dark teal
    makeColor(r: 126, g: 113, b: 75),  // dark khaki / olive brown
    makeColor(r: 184, g: 162, b: 96),  // light tan / beige-gold
    makeColor(r: 219, g: 119, b: 17)   // strong orange / ochre
  ]
  
  // Original Palette (Names from python file comments) [cite: 6, 7, 8]
  static let orig: [CGColor] = [
    makeColor(r: 40, g: 36, b: 34),    // ivory black
    makeColor(r: 12, g: 88, b: 225),   // ultramarine blue
    makeColor(r: 0, g: 179, b: 240),   // cerulean blue
    makeColor(r: 253, g: 116, b: 73),  // burnt umber (or cadmium orange?)
    makeColor(r: 200, g: 77, b: 82),   // alizarin crimson
    makeColor(r: 227, g: 23, b: 13),   // cadmium red
    makeColor(r: 138, g: 54, b: 15),   // burnt sienna
    makeColor(r: 121, g: 78, b: 0),    // raw umber
    makeColor(r: 216, g: 181, b: 0),   // yellow ochre
    makeColor(r: 235, g: 181, b: 0),   // cadmium yellow
    makeColor(r: 254, g: 253, b: 255), // titanium white
    makeColor(r: 84, g: 137, b: 62)    // sap green
  ]
  
  // Grays Palette
  static let grays: [CGColor] = [
    makeColor(r: 20, g: 20, b: 20),    // very dark gray / near black
    makeColor(r: 70, g: 70, b: 70),    // dark gray
    makeColor(r: 120, g: 120, b: 120), // medium gray
    makeColor(r: 180, g: 180, b: 180), // light gray
    makeColor(r: 240, g: 240, b: 240)  // very light gray / off-white
  ]
  
  // Red/Black Palette
  static let redBlack: [CGColor] = [
    makeColor(r: 20, g: 20, b: 20),    // very dark gray / near black
    makeColor(r: 20, g: 0, b: 0),      // very dark red
    makeColor(r: 128, g: 0, b: 0),     // dark red / maroon
    makeColor(r: 128, g: 50, b: 50),   // desaturated dark red / dusty rosewood
    makeColor(r: 240, g: 240, b: 240)  // very light gray / off-white
  ]
  
  // Just Blue Palette
  static let justBlue: [CGColor] = [
    makeColor(r: 0, g: 20, b: 20),    // very dark cyan / teal blue
    makeColor(r: 0, g: 20, b: 128),   // dark blue
    makeColor(r: 200, g: 230, b: 230) // very light cyan / pale aqua
  ]
  
  // RYB Palette
  static let ryb: [CGColor] = [
    makeColor(r: 20, g: 20, b: 20),    // very dark gray / near black
    makeColor(r: 200, g: 0, b: 0),     // strong red
    makeColor(r: 200, g: 200, b: 0),   // strong yellow / olive yellow
    makeColor(r: 0, g: 0, b: 200),     // strong blue
    makeColor(r: 200, g: 200, b: 200)  // light gray
  ]

  // Golden Cloud Palette (from Hex)
  static let goldenCloud: [CGColor] = [
    colorFromHex("171635"), colorFromHex("00225D"), colorFromHex("763262"),
    colorFromHex("CA7508"), colorFromHex("E9A621")
  ].compactMap { $0 } // Use compactMap to filter out potential nils from invalid hex codes
  
  
  // --- Collection of manually defined palettes ---
  static var allStatic: [[CGColor]] {
    return [
      saintCath, girlPearl, hokusai, letoile, mona, nighthawks, starry,
      kiss, nightwatch, scream, orig, grays, redBlack, justBlue, ryb,
      goldenCloud
    ]
  }
  
  // --- Mono Palette Generation ---
  enum MonoColorName { case red, green, blue, yellow, orange, violet }
  
  /**
   Generates a monochromatic palette by varying intensity.
   Based on mono_palette from palettes_py.txt[cite: 11, 12, 13, 14].
   */
  static func makeMonoPalette(colorName: MonoColorName, increments: Int = 4) -> [CGColor] {
    var colors: [CGColor] = []
    let step = 255.0 / CGFloat(max(1, increments)) // Avoid division by zero
    
    for i in 0...increments {
      let val = CGFloat(i) * step
      // Clamp val just in case, although loop logic should prevent > 255 if step is correct
      let intVal = Int(max(0, min(255, val)))
      
      var r = 0
      var g = 0
      var b = 0
      
      switch colorName {
        case .red:    r = intVal
        case .green:  g = intVal
        case .blue:   b = intVal
        case .yellow: r = intVal; g = intVal // [cite: 13]
        case .orange: // [cite: 14]
          r = intVal
          g = intVal / 2
          // Removed the b = val / 2 from python code[cite: 14], assuming it was a typo for orange
        case .violet: r = intVal; b = intVal // [cite: 14]
      }
      colors.append(makeColor(r: r, g: g, b: b))
    }
    return colors
  }
  
  // --- Collection of generated mono palettes ---
  static var allMonos: [[CGColor]] { // [cite: 15]
    return [
      makeMonoPalette(colorName: .red), makeMonoPalette(colorName: .green),
      makeMonoPalette(colorName: .blue), makeMonoPalette(colorName: .yellow),
      makeMonoPalette(colorName: .orange), makeMonoPalette(colorName: .violet)
    ]
  }
  
  // --- Collection of ALL palettes (static + mono) ---
  static var all: [[CGColor]] { // Roughly equivalent to python return palettes [cite: 10]
    return allStatic + allMonos
  }
  
  
  
} // End enum Palettes


--- End of Context ---
